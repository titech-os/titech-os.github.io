<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>buf</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.1' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/2.html#L32'>buf</a>                32 bio.c            struct buf buf[NBUF];</span>
<span class='curline'><a href='../S/2.html#L36'>buf</a>                36 bio.c            struct buf head;</span>
<span class='curline'><a href='../S/2.html#L42'>buf</a>                42 bio.c            struct buf *b;</span>
<span class='curline'><a href='../S/2.html#L50'>buf</a>                50 bio.c            for(b = bcache.buf; b &lt; bcache.buf+NBUF; b++){</span>
<span class='curline'><a href='../S/2.html#L62'>buf</a>                62 bio.c          static struct buf*</span>
<span class='curline'><a href='../S/2.html#L65'>buf</a>                65 bio.c            struct buf *b;</span>
<span class='curline'><a href='../S/2.html#L99'>buf</a>                99 bio.c          struct buf*</span>
<span class='curline'><a href='../S/2.html#L102'>buf</a>               102 bio.c            struct buf *b;</span>
<span class='curline'><a href='../S/2.html#L113'>buf</a>               113 bio.c          bwrite(struct buf *b)</span>
<span class='curline'><a href='../S/2.html#L124'>buf</a>               124 bio.c          brelse(struct buf *b)</span>
<span class='curline'><a href='../S/5.html#L5'>buf</a>                 5 buf.h            struct buf *prev; // LRU cache list</span>
<span class='curline'><a href='../S/5.html#L6'>buf</a>                 6 buf.h            struct buf *next;</span>
<span class='curline'><a href='../S/5.html#L7'>buf</a>                 7 buf.h            struct buf *qnext; // disk queue</span>
<span class='curline'><a href='../S/7.html#L5'>buf</a>                 5 cat.c          char buf[512];</span>
<span class='curline'><a href='../S/7.html#L12'>buf</a>                12 cat.c            while((n = read(fd, buf, sizeof(buf))) &gt; 0)</span>
<span class='curline'><a href='../S/7.html#L13'>buf</a>                13 cat.c              write(1, buf, n);</span>
<span class='curline'><a href='../S/8.html#L30'>buf</a>                30 console.c        char buf[16];</span>
<span class='curline'><a href='../S/8.html#L41'>buf</a>                41 console.c          buf[i++] = digits[x % base];</span>
<span class='curline'><a href='../S/8.html#L45'>buf</a>                45 console.c          buf[i++] = '-';</span>
<span class='curline'><a href='../S/8.html#L48'>buf</a>                48 console.c          consputc(buf[i]);</span>
<span class='curline'><a href='../S/8.html#L179'>buf</a>               179 console.c        char buf[INPUT_BUF];</span>
<span class='curline'><a href='../S/8.html#L200'>buf</a>               200 console.c                  input.buf[(input.e-1) % INPUT_BUF] != '\n'){</span>
<span class='curline'><a href='../S/8.html#L214'>buf</a>               214 console.c              input.buf[input.e++ % INPUT_BUF] = c;</span>
<span class='curline'><a href='../S/8.html#L245'>buf</a>               245 console.c          c = input.buf[input.r++ % INPUT_BUF];</span>
<span class='curline'><a href='../S/8.html#L266'>buf</a>               266 console.c      consolewrite(struct inode *ip, char *buf, int n)</span>
<span class='curline'><a href='../S/8.html#L273'>buf</a>               273 console.c          consputc(buf[i] &amp; 0xff);</span>
<span class='curline'><a href='../S/11.html#L1'>buf</a>                 1 defs.h         struct buf;</span>
<span class='curline'><a href='../S/11.html#L14'>buf</a>                14 defs.h         struct buf*     bread(uint, uint);</span>
<span class='curline'><a href='../S/11.html#L15'>buf</a>                15 defs.h         void            brelse(struct buf*);</span>
<span class='curline'><a href='../S/11.html#L16'>buf</a>                16 defs.h         void            bwrite(struct buf*);</span>
<span class='curline'><a href='../S/11.html#L58'>buf</a>                58 defs.h         void            iderw(struct buf*);</span>
<span class='curline'><a href='../S/11.html#L85'>buf</a>                85 defs.h         void            log_write(struct buf*);</span>
<span class='curline'><a href='../S/22.html#L31'>buf</a>                31 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/22.html#L42'>buf</a>                42 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/22.html#L57'>buf</a>                57 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/22.html#L81'>buf</a>                81 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/22.html#L180'>buf</a>               180 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/22.html#L202'>buf</a>               202 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/22.html#L269'>buf</a>               269 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/22.html#L360'>buf</a>               360 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/22.html#L395'>buf</a>               395 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/22.html#L438'>buf</a>               438 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/22.html#L466'>buf</a>               466 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/25.html#L7'>buf</a>                 7 grep.c         char buf[1024];</span>
<span class='curline'><a href='../S/25.html#L17'>buf</a>                17 grep.c           while((n = read(fd, buf+m, sizeof(buf)-m-1)) &gt; 0){</span>
<span class='curline'><a href='../S/25.html#L19'>buf</a>                19 grep.c             buf[m] = '\0';</span>
<span class='curline'><a href='../S/25.html#L20'>buf</a>                20 grep.c             p = buf;</span>
<span class='curline'><a href='../S/25.html#L29'>buf</a>                29 grep.c             if(p == buf)</span>
<span class='curline'><a href='../S/25.html#L32'>buf</a>                32 grep.c               m -= p - buf;</span>
<span class='curline'><a href='../S/25.html#L33'>buf</a>                33 grep.c               memmove(buf, p, m);</span>
<span class='curline'><a href='../S/26.html#L29'>buf</a>                29 ide.c          static struct buf *idequeue;</span>
<span class='curline'><a href='../S/26.html#L32'>buf</a>                32 ide.c          static void idestart(struct buf*);</span>
<span class='curline'><a href='../S/26.html#L72'>buf</a>                72 ide.c          idestart(struct buf *b)</span>
<span class='curline'><a href='../S/26.html#L102'>buf</a>               102 ide.c            struct buf *b;</span>
<span class='curline'><a href='../S/26.html#L134'>buf</a>               134 ide.c          iderw(struct buf *b)</span>
<span class='curline'><a href='../S/26.html#L136'>buf</a>               136 ide.c            struct buf **pp;</span>
<span class='curline'><a href='../S/38.html#L74'>buf</a>                74 log.c              struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block</span>
<span class='curline'><a href='../S/38.html#L75'>buf</a>                75 log.c              struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst</span>
<span class='curline'><a href='../S/38.html#L87'>buf</a>                87 log.c            struct buf *buf = bread(log.dev, log.start);</span>
<span class='curline'><a href='../S/38.html#L88'>buf</a>                88 log.c            struct logheader *lh = (struct logheader *) (buf-&gt;data);</span>
<span class='curline'><a href='../S/38.html#L94'>buf</a>                94 log.c            brelse(buf);</span>
<span class='curline'><a href='../S/38.html#L103'>buf</a>               103 log.c            struct buf *buf = bread(log.dev, log.start);</span>
<span class='curline'><a href='../S/38.html#L104'>buf</a>               104 log.c            struct logheader *hb = (struct logheader *) (buf-&gt;data);</span>
<span class='curline'><a href='../S/38.html#L110'>buf</a>               110 log.c            bwrite(buf);</span>
<span class='curline'><a href='../S/38.html#L111'>buf</a>               111 log.c            brelse(buf);</span>
<span class='curline'><a href='../S/38.html#L180'>buf</a>               180 log.c              struct buf *to = bread(log.dev, log.start+tail+1); // log block</span>
<span class='curline'><a href='../S/38.html#L181'>buf</a>               181 log.c              struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block</span>
<span class='curline'><a href='../S/38.html#L211'>buf</a>               211 log.c          log_write(struct buf *b)</span>
<span class='curline'><a href='../S/39.html#L9'>buf</a>                 9 ls.c             static char buf[DIRSIZ+1];</span>
<span class='curline'><a href='../S/39.html#L20'>buf</a>                20 ls.c             memmove(buf, p, strlen(p));</span>
<span class='curline'><a href='../S/39.html#L21'>buf</a>                21 ls.c             memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));</span>
<span class='curline'><a href='../S/39.html#L22'>buf</a>                22 ls.c             return buf;</span>
<span class='curline'><a href='../S/39.html#L28'>buf</a>                28 ls.c             char buf[512], *p;</span>
<span class='curline'><a href='../S/39.html#L50'>buf</a>                50 ls.c               if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf){</span>
<span class='curline'><a href='../S/39.html#L54'>buf</a>                54 ls.c               strcpy(buf, path);</span>
<span class='curline'><a href='../S/39.html#L55'>buf</a>                55 ls.c               p = buf+strlen(buf);</span>
<span class='curline'><a href='../S/39.html#L62'>buf</a>                62 ls.c                 if(stat(buf, &amp;st) &lt; 0){</span>
<span class='curline'><a href='../S/39.html#L63'>buf</a>                63 ls.c                   printf(1, "ls: cannot stat %s\n", buf);</span>
<span class='curline'><a href='../S/39.html#L66'>buf</a>                66 ls.c                 printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);</span>
<span class='curline'><a href='../S/42.html#L38'>buf</a>                38 memide.c       iderw(struct buf *b)</span>
<span class='curline'><a href='../S/45.html#L40'>buf</a>                40 mkfs.c         void rsect(uint sec, void *buf);</span>
<span class='curline'><a href='../S/45.html#L73'>buf</a>                73 mkfs.c           char buf[BSIZE];</span>
<span class='curline'><a href='../S/45.html#L113'>buf</a>               113 mkfs.c           memset(buf, 0, sizeof(buf));</span>
<span class='curline'><a href='../S/45.html#L114'>buf</a>               114 mkfs.c           memmove(buf, &amp;sb, sizeof(sb));</span>
<span class='curline'><a href='../S/45.html#L115'>buf</a>               115 mkfs.c           wsect(1, buf);</span>
<span class='curline'><a href='../S/45.html#L152'>buf</a>               152 mkfs.c             while((cc = read(fd, buf, sizeof(buf))) &gt; 0)</span>
<span class='curline'><a href='../S/45.html#L153'>buf</a>               153 mkfs.c               iappend(inum, buf, cc);</span>
<span class='curline'><a href='../S/45.html#L171'>buf</a>               171 mkfs.c         wsect(uint sec, void *buf)</span>
<span class='curline'><a href='../S/45.html#L177'>buf</a>               177 mkfs.c           if(write(fsfd, buf, BSIZE) != BSIZE){</span>
<span class='curline'><a href='../S/45.html#L186'>buf</a>               186 mkfs.c           char buf[BSIZE];</span>
<span class='curline'><a href='../S/45.html#L191'>buf</a>               191 mkfs.c           rsect(bn, buf);</span>
<span class='curline'><a href='../S/45.html#L192'>buf</a>               192 mkfs.c           dip = ((struct dinode*)buf) + (inum % IPB);</span>
<span class='curline'><a href='../S/45.html#L194'>buf</a>               194 mkfs.c           wsect(bn, buf);</span>
<span class='curline'><a href='../S/45.html#L200'>buf</a>               200 mkfs.c           char buf[BSIZE];</span>
<span class='curline'><a href='../S/45.html#L205'>buf</a>               205 mkfs.c           rsect(bn, buf);</span>
<span class='curline'><a href='../S/45.html#L206'>buf</a>               206 mkfs.c           dip = ((struct dinode*)buf) + (inum % IPB);</span>
<span class='curline'><a href='../S/45.html#L211'>buf</a>               211 mkfs.c         rsect(uint sec, void *buf)</span>
<span class='curline'><a href='../S/45.html#L217'>buf</a>               217 mkfs.c           if(read(fsfd, buf, BSIZE) != BSIZE){</span>
<span class='curline'><a href='../S/45.html#L240'>buf</a>               240 mkfs.c           uchar buf[BSIZE];</span>
<span class='curline'><a href='../S/45.html#L245'>buf</a>               245 mkfs.c           bzero(buf, BSIZE);</span>
<span class='curline'><a href='../S/45.html#L247'>buf</a>               247 mkfs.c             buf[i/8] = buf[i/8] | (0x1 &lt;&lt; (i%8));</span>
<span class='curline'><a href='../S/45.html#L250'>buf</a>               250 mkfs.c           wsect(sb.bmapstart, buf);</span>
<span class='curline'><a href='../S/45.html#L261'>buf</a>               261 mkfs.c           char buf[BSIZE];</span>
<span class='curline'><a href='../S/45.html#L288'>buf</a>               288 mkfs.c             rsect(x, buf);</span>
<span class='curline'><a href='../S/45.html#L289'>buf</a>               289 mkfs.c             bcopy(p, buf + off - (fbn * BSIZE), n1);</span>
<span class='curline'><a href='../S/45.html#L290'>buf</a>               290 mkfs.c             wsect(x, buf);</span>
<span class='curline'><a href='../S/54.html#L15'>buf</a>                15 printf.c         char buf[16];</span>
<span class='curline'><a href='../S/54.html#L29'>buf</a>                29 printf.c           buf[i++] = digits[x % base];</span>
<span class='curline'><a href='../S/54.html#L32'>buf</a>                32 printf.c           buf[i++] = '-';</span>
<span class='curline'><a href='../S/54.html#L35'>buf</a>                35 printf.c           putc(fd, buf[i]);</span>
<span class='curline'><a href='../S/64.html#L134'>buf</a>               134 sh.c           getcmd(char *buf, int nbuf)</span>
<span class='curline'><a href='../S/64.html#L137'>buf</a>               137 sh.c             memset(buf, 0, nbuf);</span>
<span class='curline'><a href='../S/64.html#L138'>buf</a>               138 sh.c             gets(buf, nbuf);</span>
<span class='curline'><a href='../S/64.html#L139'>buf</a>               139 sh.c             if(buf[0] == 0) // EOF</span>
<span class='curline'><a href='../S/64.html#L147'>buf</a>               147 sh.c             static char buf[100];</span>
<span class='curline'><a href='../S/64.html#L159'>buf</a>               159 sh.c             while(getcmd(buf, sizeof(buf)) &gt;= 0){</span>
<span class='curline'><a href='../S/64.html#L160'>buf</a>               160 sh.c               if(buf[0] == 'c' &amp;&amp; buf[1] == 'd' &amp;&amp; buf[2] == ' '){</span>
<span class='curline'><a href='../S/64.html#L163'>buf</a>               163 sh.c                 buf[strlen(buf)-1] = 0;  // chop \n</span>
<span class='curline'><a href='../S/64.html#L164'>buf</a>               164 sh.c                 if(chdir(buf+3) &lt; 0)</span>
<span class='curline'><a href='../S/64.html#L165'>buf</a>               165 sh.c                   printf(2, "cannot cd %s\n", buf+3);</span>
<span class='curline'><a href='../S/64.html#L169'>buf</a>               169 sh.c                 runcmd(parsecmd(buf));</span>
<span class='curline'><a href='../S/89.html#L53'>buf</a>                53 ulib.c         gets(char *buf, int max)</span>
<span class='curline'><a href='../S/89.html#L62'>buf</a>                62 ulib.c             buf[i++] = c;</span>
<span class='curline'><a href='../S/89.html#L66'>buf</a>                66 ulib.c           buf[i] = '\0';</span>
<span class='curline'><a href='../S/89.html#L67'>buf</a>                67 ulib.c           return buf;</span>
<span class='curline'><a href='../S/92.html#L11'>buf</a>                11 usertests.c    char buf[8192];</span>
<span class='curline'><a href='../S/92.html#L171'>buf</a>               171 usertests.c      i = read(fd, buf, 2000);</span>
<span class='curline'><a href='../S/92.html#L201'>buf</a>               201 usertests.c        ((int*)buf)[0] = i;</span>
<span class='curline'><a href='../S/92.html#L202'>buf</a>               202 usertests.c        if(write(fd, buf, 512) != 512){</span>
<span class='curline'><a href='../S/92.html#L218'>buf</a>               218 usertests.c        i = read(fd, buf, 512);</span>
<span class='curline'><a href='../S/92.html#L229'>buf</a>               229 usertests.c        if(((int*)buf)[0] != n){</span>
<span class='curline'><a href='../S/92.html#L231'>buf</a>               231 usertests.c                 n, ((int*)buf)[0]);</span>
<span class='curline'><a href='../S/92.html#L321'>buf</a>               321 usertests.c            buf[i] = seq++;</span>
<span class='curline'><a href='../S/92.html#L322'>buf</a>               322 usertests.c          if(write(fds[1], buf, 1033) != 1033){</span>
<span class='curline'><a href='../S/92.html#L332'>buf</a>               332 usertests.c        while((n = read(fds[0], buf, cc)) &gt; 0){</span>
<span class='curline'><a href='../S/92.html#L334'>buf</a>               334 usertests.c            if((buf[i] &amp; 0xff) != (seq++ &amp; 0xff)){</span>
<span class='curline'><a href='../S/92.html#L341'>buf</a>               341 usertests.c          if(cc &gt; sizeof(buf))</span>
<span class='curline'><a href='../S/92.html#L342'>buf</a>               342 usertests.c            cc = sizeof(buf);</span>
<span class='curline'><a href='../S/92.html#L387'>buf</a>               387 usertests.c      if(read(pfds[0], buf, sizeof(buf)) != 1){</span>
<span class='curline'><a href='../S/92.html#L468'>buf</a>               468 usertests.c      char buf[10];</span>
<span class='curline'><a href='../S/92.html#L479'>buf</a>               479 usertests.c      memset(buf, pid==0?'c':'p', sizeof(buf));</span>
<span class='curline'><a href='../S/92.html#L481'>buf</a>               481 usertests.c        if(write(fd, buf, sizeof(buf)) != sizeof(buf)){</span>
<span class='curline'><a href='../S/92.html#L497'>buf</a>               497 usertests.c      while((n = read(fd, buf, sizeof(buf))) &gt; 0){</span>
<span class='curline'><a href='../S/92.html#L498'>buf</a>               498 usertests.c        for(i = 0; i &lt; sizeof(buf); i++){</span>
<span class='curline'><a href='../S/92.html#L499'>buf</a>               499 usertests.c          if(buf[i] == 'c')</span>
<span class='curline'><a href='../S/92.html#L501'>buf</a>               501 usertests.c          if(buf[i] == 'p')</span>
<span class='curline'><a href='../S/92.html#L543'>buf</a>               543 usertests.c          memset(buf, '0'+pi, 512);</span>
<span class='curline'><a href='../S/92.html#L545'>buf</a>               545 usertests.c            if((n = write(fd, buf, 500)) != 500){</span>
<span class='curline'><a href='../S/92.html#L562'>buf</a>               562 usertests.c        while((n = read(fd, buf, sizeof(buf))) &gt; 0){</span>
<span class='curline'><a href='../S/92.html#L564'>buf</a>               564 usertests.c            if(buf[j] != '0'+i){</span>
<span class='curline'><a href='../S/92.html#L684'>buf</a>               684 usertests.c      if(read(fd, buf, sizeof(buf)) != 5){</span>
<span class='curline'><a href='../S/92.html#L688'>buf</a>               688 usertests.c      if(buf[0] != 'h'){</span>
<span class='curline'><a href='../S/92.html#L692'>buf</a>               692 usertests.c      if(write(fd, buf, 10) != 10){</span>
<span class='curline'><a href='../S/92.html#L738'>buf</a>               738 usertests.c      if(read(fd, buf, sizeof(buf)) != 5){</span>
<span class='curline'><a href='../S/92.html#L978'>buf</a>               978 usertests.c      cc = read(fd, buf, sizeof(buf));</span>
<span class='curline'><a href='../S/92.html#L979'>buf</a>               979 usertests.c      if(cc != 2 || buf[0] != 'f'){</span>
<span class='curline'><a href='../S/92.html#L1021'>buf</a>              1021 usertests.c      if(read(fd, buf, sizeof(buf)) != 2){</span>
<span class='curline'><a href='../S/92.html#L1134'>buf</a>              1134 usertests.c          int cc = write(fd, buf, sz);</span>
<span class='curline'><a href='../S/92.html#L1161'>buf</a>              1161 usertests.c        memset(buf, i, 600);</span>
<span class='curline'><a href='../S/92.html#L1162'>buf</a>              1162 usertests.c        if(write(fd, buf, 600) != 600){</span>
<span class='curline'><a href='../S/92.html#L1176'>buf</a>              1176 usertests.c        cc = read(fd, buf, 300);</span>
<span class='curline'><a href='../S/92.html#L1187'>buf</a>              1187 usertests.c        if(buf[0] != i/2 || buf[299] != i/2){</span>
<span class='curline'><a href='../S/92.html#L1671'>buf</a>              1671 usertests.c          int cc = write(fd, buf, 512);</span>
<span class='curline'><a href='../S/95.html#L360'>buf</a>               360 vm.c             char *buf, *pa0;</span>
<span class='curline'><a href='../S/95.html#L363'>buf</a>               363 vm.c             buf = (char*)p;</span>
<span class='curline'><a href='../S/95.html#L372'>buf</a>               372 vm.c               memmove(pa0 + (va - va0), buf, n);</span>
<span class='curline'><a href='../S/95.html#L374'>buf</a>               374 vm.c               buf += n;</span>
<span class='curline'><a href='../S/96.html#L5'>buf</a>                 5 wc.c           char buf[512];</span>
<span class='curline'><a href='../S/96.html#L15'>buf</a>                15 wc.c             while((n = read(fd, buf, sizeof(buf))) &gt; 0){</span>
<span class='curline'><a href='../S/96.html#L18'>buf</a>                18 wc.c                 if(buf[i] == '\n')</span>
<span class='curline'><a href='../S/96.html#L20'>buf</a>                20 wc.c                 if(strchr(" \r\t\n\v", buf[i]))</span>
</pre>
</body>
</html>
