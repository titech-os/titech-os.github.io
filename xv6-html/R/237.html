<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>buf</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.2' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/71.html#L31'>buf</a>                31 bio.c            struct buf buf[NBUF];</span>
<span class='curline'><a href='../S/71.html#L35'>buf</a>                35 bio.c            struct buf head;</span>
<span class='curline'><a href='../S/71.html#L41'>buf</a>                41 bio.c            struct buf *b;</span>
<span class='curline'><a href='../S/71.html#L49'>buf</a>                49 bio.c            for(b = bcache.buf; b &lt; bcache.buf+NBUF; b++){</span>
<span class='curline'><a href='../S/71.html#L61'>buf</a>                61 bio.c          static struct buf*</span>
<span class='curline'><a href='../S/71.html#L64'>buf</a>                64 bio.c            struct buf *b;</span>
<span class='curline'><a href='../S/71.html#L96'>buf</a>                96 bio.c          struct buf*</span>
<span class='curline'><a href='../S/71.html#L99'>buf</a>                99 bio.c            struct buf *b;</span>
<span class='curline'><a href='../S/71.html#L110'>buf</a>               110 bio.c          bwrite(struct buf *b)</span>
<span class='curline'><a href='../S/71.html#L121'>buf</a>               121 bio.c          brelse(struct buf *b)</span>
<span class='curline'><a href='../S/40.html#L7'>buf</a>                 7 buf.h            struct buf *prev; // LRU cache list</span>
<span class='curline'><a href='../S/40.html#L8'>buf</a>                 8 buf.h            struct buf *next;</span>
<span class='curline'><a href='../S/40.html#L9'>buf</a>                 9 buf.h            struct buf *qnext; // disk queue</span>
<span class='curline'><a href='../S/35.html#L5'>buf</a>                 5 cat.c          char buf[512];</span>
<span class='curline'><a href='../S/35.html#L12'>buf</a>                12 cat.c            while((n = read(fd, buf, sizeof(buf))) &gt; 0) {</span>
<span class='curline'><a href='../S/35.html#L13'>buf</a>                13 cat.c              if (write(1, buf, n) != n) {</span>
<span class='curline'><a href='../S/64.html#L31'>buf</a>                31 console.c        char buf[16];</span>
<span class='curline'><a href='../S/64.html#L42'>buf</a>                42 console.c          buf[i++] = digits[x % base];</span>
<span class='curline'><a href='../S/64.html#L46'>buf</a>                46 console.c          buf[i++] = '-';</span>
<span class='curline'><a href='../S/64.html#L49'>buf</a>                49 console.c          consputc(buf[i]);</span>
<span class='curline'><a href='../S/64.html#L183'>buf</a>               183 console.c        char buf[INPUT_BUF];</span>
<span class='curline'><a href='../S/64.html#L205'>buf</a>               205 console.c                  input.buf[(input.e-1) % INPUT_BUF] != '\n'){</span>
<span class='curline'><a href='../S/64.html#L219'>buf</a>               219 console.c              input.buf[input.e++ % INPUT_BUF] = c;</span>
<span class='curline'><a href='../S/64.html#L253'>buf</a>               253 console.c          c = input.buf[input.r++ % INPUT_BUF];</span>
<span class='curline'><a href='../S/64.html#L274'>buf</a>               274 console.c      consolewrite(struct inode *ip, char *buf, int n)</span>
<span class='curline'><a href='../S/64.html#L281'>buf</a>               281 console.c          consputc(buf[i] &amp; 0xff);</span>
<span class='curline'><a href='../S/9.html#L1'>buf</a>                 1 defs.h         struct buf;</span>
<span class='curline'><a href='../S/9.html#L15'>buf</a>                15 defs.h         struct buf*     bread(uint, uint);</span>
<span class='curline'><a href='../S/9.html#L16'>buf</a>                16 defs.h         void            brelse(struct buf*);</span>
<span class='curline'><a href='../S/9.html#L17'>buf</a>                17 defs.h         void            bwrite(struct buf*);</span>
<span class='curline'><a href='../S/9.html#L59'>buf</a>                59 defs.h         void            iderw(struct buf*);</span>
<span class='curline'><a href='../S/9.html#L86'>buf</a>                86 defs.h         void            log_write(struct buf*);</span>
<span class='curline'><a href='../S/46.html#L34'>buf</a>                34 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/46.html#L45'>buf</a>                45 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/46.html#L60'>buf</a>                60 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/46.html#L84'>buf</a>                84 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/46.html#L199'>buf</a>               199 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/46.html#L224'>buf</a>               224 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/46.html#L291'>buf</a>               291 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/46.html#L377'>buf</a>               377 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/46.html#L412'>buf</a>               412 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/46.html#L457'>buf</a>               457 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/46.html#L486'>buf</a>               486 fs.c             struct buf *bp;</span>
<span class='curline'><a href='../S/88.html#L7'>buf</a>                 7 grep.c         char buf[1024];</span>
<span class='curline'><a href='../S/88.html#L17'>buf</a>                17 grep.c           while((n = read(fd, buf+m, sizeof(buf)-m-1)) &gt; 0){</span>
<span class='curline'><a href='../S/88.html#L19'>buf</a>                19 grep.c             buf[m] = '\0';</span>
<span class='curline'><a href='../S/88.html#L20'>buf</a>                20 grep.c             p = buf;</span>
<span class='curline'><a href='../S/88.html#L29'>buf</a>                29 grep.c             if(p == buf)</span>
<span class='curline'><a href='../S/88.html#L32'>buf</a>                32 grep.c               m -= p - buf;</span>
<span class='curline'><a href='../S/88.html#L33'>buf</a>                33 grep.c               memmove(buf, p, m);</span>
<span class='curline'><a href='../S/81.html#L32'>buf</a>                32 ide.c          static struct buf *idequeue;</span>
<span class='curline'><a href='../S/81.html#L35'>buf</a>                35 ide.c          static void idestart(struct buf*);</span>
<span class='curline'><a href='../S/81.html#L74'>buf</a>                74 ide.c          idestart(struct buf *b)</span>
<span class='curline'><a href='../S/81.html#L106'>buf</a>               106 ide.c            struct buf *b;</span>
<span class='curline'><a href='../S/81.html#L138'>buf</a>               138 ide.c          iderw(struct buf *b)</span>
<span class='curline'><a href='../S/81.html#L140'>buf</a>               140 ide.c            struct buf **pp;</span>
<span class='curline'><a href='../S/4.html#L75'>buf</a>                75 log.c              struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block</span>
<span class='curline'><a href='../S/4.html#L76'>buf</a>                76 log.c              struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst</span>
<span class='curline'><a href='../S/4.html#L88'>buf</a>                88 log.c            struct buf *buf = bread(log.dev, log.start);</span>
<span class='curline'><a href='../S/4.html#L89'>buf</a>                89 log.c            struct logheader *lh = (struct logheader *) (buf-&gt;data);</span>
<span class='curline'><a href='../S/4.html#L95'>buf</a>                95 log.c            brelse(buf);</span>
<span class='curline'><a href='../S/4.html#L104'>buf</a>               104 log.c            struct buf *buf = bread(log.dev, log.start);</span>
<span class='curline'><a href='../S/4.html#L105'>buf</a>               105 log.c            struct logheader *hb = (struct logheader *) (buf-&gt;data);</span>
<span class='curline'><a href='../S/4.html#L111'>buf</a>               111 log.c            bwrite(buf);</span>
<span class='curline'><a href='../S/4.html#L112'>buf</a>               112 log.c            brelse(buf);</span>
<span class='curline'><a href='../S/4.html#L183'>buf</a>               183 log.c              struct buf *to = bread(log.dev, log.start+tail+1); // log block</span>
<span class='curline'><a href='../S/4.html#L184'>buf</a>               184 log.c              struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block</span>
<span class='curline'><a href='../S/4.html#L214'>buf</a>               214 log.c          log_write(struct buf *b)</span>
<span class='curline'><a href='../S/12.html#L9'>buf</a>                 9 ls.c             static char buf[DIRSIZ+1];</span>
<span class='curline'><a href='../S/12.html#L20'>buf</a>                20 ls.c             memmove(buf, p, strlen(p));</span>
<span class='curline'><a href='../S/12.html#L21'>buf</a>                21 ls.c             memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));</span>
<span class='curline'><a href='../S/12.html#L22'>buf</a>                22 ls.c             return buf;</span>
<span class='curline'><a href='../S/12.html#L28'>buf</a>                28 ls.c             char buf[512], *p;</span>
<span class='curline'><a href='../S/12.html#L50'>buf</a>                50 ls.c               if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf){</span>
<span class='curline'><a href='../S/12.html#L54'>buf</a>                54 ls.c               strcpy(buf, path);</span>
<span class='curline'><a href='../S/12.html#L55'>buf</a>                55 ls.c               p = buf+strlen(buf);</span>
<span class='curline'><a href='../S/12.html#L62'>buf</a>                62 ls.c                 if(stat(buf, &amp;st) &lt; 0){</span>
<span class='curline'><a href='../S/12.html#L63'>buf</a>                63 ls.c                   printf(1, "ls: cannot stat %s\n", buf);</span>
<span class='curline'><a href='../S/12.html#L66'>buf</a>                66 ls.c                 printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);</span>
<span class='curline'><a href='../S/44.html#L39'>buf</a>                39 memide.c       iderw(struct buf *b)</span>
<span class='curline'><a href='../S/86.html#L40'>buf</a>                40 mkfs.c         void rsect(uint sec, void *buf);</span>
<span class='curline'><a href='../S/86.html#L73'>buf</a>                73 mkfs.c           char buf[BSIZE];</span>
<span class='curline'><a href='../S/86.html#L113'>buf</a>               113 mkfs.c           memset(buf, 0, sizeof(buf));</span>
<span class='curline'><a href='../S/86.html#L114'>buf</a>               114 mkfs.c           memmove(buf, &amp;sb, sizeof(sb));</span>
<span class='curline'><a href='../S/86.html#L115'>buf</a>               115 mkfs.c           wsect(1, buf);</span>
<span class='curline'><a href='../S/86.html#L152'>buf</a>               152 mkfs.c             while((cc = read(fd, buf, sizeof(buf))) &gt; 0)</span>
<span class='curline'><a href='../S/86.html#L153'>buf</a>               153 mkfs.c               iappend(inum, buf, cc);</span>
<span class='curline'><a href='../S/86.html#L171'>buf</a>               171 mkfs.c         wsect(uint sec, void *buf)</span>
<span class='curline'><a href='../S/86.html#L177'>buf</a>               177 mkfs.c           if(write(fsfd, buf, BSIZE) != BSIZE){</span>
<span class='curline'><a href='../S/86.html#L186'>buf</a>               186 mkfs.c           char buf[BSIZE];</span>
<span class='curline'><a href='../S/86.html#L191'>buf</a>               191 mkfs.c           rsect(bn, buf);</span>
<span class='curline'><a href='../S/86.html#L192'>buf</a>               192 mkfs.c           dip = ((struct dinode*)buf) + (inum % IPB);</span>
<span class='curline'><a href='../S/86.html#L194'>buf</a>               194 mkfs.c           wsect(bn, buf);</span>
<span class='curline'><a href='../S/86.html#L200'>buf</a>               200 mkfs.c           char buf[BSIZE];</span>
<span class='curline'><a href='../S/86.html#L205'>buf</a>               205 mkfs.c           rsect(bn, buf);</span>
<span class='curline'><a href='../S/86.html#L206'>buf</a>               206 mkfs.c           dip = ((struct dinode*)buf) + (inum % IPB);</span>
<span class='curline'><a href='../S/86.html#L211'>buf</a>               211 mkfs.c         rsect(uint sec, void *buf)</span>
<span class='curline'><a href='../S/86.html#L217'>buf</a>               217 mkfs.c           if(read(fsfd, buf, BSIZE) != BSIZE){</span>
<span class='curline'><a href='../S/86.html#L240'>buf</a>               240 mkfs.c           uchar buf[BSIZE];</span>
<span class='curline'><a href='../S/86.html#L245'>buf</a>               245 mkfs.c           bzero(buf, BSIZE);</span>
<span class='curline'><a href='../S/86.html#L247'>buf</a>               247 mkfs.c             buf[i/8] = buf[i/8] | (0x1 &lt;&lt; (i%8));</span>
<span class='curline'><a href='../S/86.html#L250'>buf</a>               250 mkfs.c           wsect(sb.bmapstart, buf);</span>
<span class='curline'><a href='../S/86.html#L261'>buf</a>               261 mkfs.c           char buf[BSIZE];</span>
<span class='curline'><a href='../S/86.html#L288'>buf</a>               288 mkfs.c             rsect(x, buf);</span>
<span class='curline'><a href='../S/86.html#L289'>buf</a>               289 mkfs.c             bcopy(p, buf + off - (fbn * BSIZE), n1);</span>
<span class='curline'><a href='../S/86.html#L290'>buf</a>               290 mkfs.c             wsect(x, buf);</span>
<span class='curline'><a href='../S/6.html#L15'>buf</a>                15 printf.c         char buf[16];</span>
<span class='curline'><a href='../S/6.html#L29'>buf</a>                29 printf.c           buf[i++] = digits[x % base];</span>
<span class='curline'><a href='../S/6.html#L32'>buf</a>                32 printf.c           buf[i++] = '-';</span>
<span class='curline'><a href='../S/6.html#L35'>buf</a>                35 printf.c           putc(fd, buf[i]);</span>
<span class='curline'><a href='../S/74.html#L134'>buf</a>               134 sh.c           getcmd(char *buf, int nbuf)</span>
<span class='curline'><a href='../S/74.html#L137'>buf</a>               137 sh.c             memset(buf, 0, nbuf);</span>
<span class='curline'><a href='../S/74.html#L138'>buf</a>               138 sh.c             gets(buf, nbuf);</span>
<span class='curline'><a href='../S/74.html#L139'>buf</a>               139 sh.c             if(buf[0] == 0) // EOF</span>
<span class='curline'><a href='../S/74.html#L147'>buf</a>               147 sh.c             static char buf[100];</span>
<span class='curline'><a href='../S/74.html#L159'>buf</a>               159 sh.c             while(getcmd(buf, sizeof(buf)) &gt;= 0){</span>
<span class='curline'><a href='../S/74.html#L160'>buf</a>               160 sh.c               if(buf[0] == 'c' &amp;&amp; buf[1] == 'd' &amp;&amp; buf[2] == ' '){</span>
<span class='curline'><a href='../S/74.html#L162'>buf</a>               162 sh.c                 buf[strlen(buf)-1] = 0;  // chop \n</span>
<span class='curline'><a href='../S/74.html#L163'>buf</a>               163 sh.c                 if(chdir(buf+3) &lt; 0)</span>
<span class='curline'><a href='../S/74.html#L164'>buf</a>               164 sh.c                   printf(2, "cannot cd %s\n", buf+3);</span>
<span class='curline'><a href='../S/74.html#L168'>buf</a>               168 sh.c                 runcmd(parsecmd(buf));</span>
<span class='curline'><a href='../S/82.html#L53'>buf</a>                53 ulib.c         gets(char *buf, int max)</span>
<span class='curline'><a href='../S/82.html#L62'>buf</a>                62 ulib.c             buf[i++] = c;</span>
<span class='curline'><a href='../S/82.html#L66'>buf</a>                66 ulib.c           buf[i] = '\0';</span>
<span class='curline'><a href='../S/82.html#L67'>buf</a>                67 ulib.c           return buf;</span>
<span class='curline'><a href='../S/96.html#L11'>buf</a>                11 usertests.c    char buf[8192];</span>
<span class='curline'><a href='../S/96.html#L171'>buf</a>               171 usertests.c      i = read(fd, buf, 2000);</span>
<span class='curline'><a href='../S/96.html#L201'>buf</a>               201 usertests.c        ((int*)buf)[0] = i;</span>
<span class='curline'><a href='../S/96.html#L202'>buf</a>               202 usertests.c        if(write(fd, buf, 512) != 512){</span>
<span class='curline'><a href='../S/96.html#L218'>buf</a>               218 usertests.c        i = read(fd, buf, 512);</span>
<span class='curline'><a href='../S/96.html#L229'>buf</a>               229 usertests.c        if(((int*)buf)[0] != n){</span>
<span class='curline'><a href='../S/96.html#L231'>buf</a>               231 usertests.c                 n, ((int*)buf)[0]);</span>
<span class='curline'><a href='../S/96.html#L321'>buf</a>               321 usertests.c            buf[i] = seq++;</span>
<span class='curline'><a href='../S/96.html#L322'>buf</a>               322 usertests.c          if(write(fds[1], buf, 1033) != 1033){</span>
<span class='curline'><a href='../S/96.html#L332'>buf</a>               332 usertests.c        while((n = read(fds[0], buf, cc)) &gt; 0){</span>
<span class='curline'><a href='../S/96.html#L334'>buf</a>               334 usertests.c            if((buf[i] &amp; 0xff) != (seq++ &amp; 0xff)){</span>
<span class='curline'><a href='../S/96.html#L341'>buf</a>               341 usertests.c          if(cc &gt; sizeof(buf))</span>
<span class='curline'><a href='../S/96.html#L342'>buf</a>               342 usertests.c            cc = sizeof(buf);</span>
<span class='curline'><a href='../S/96.html#L387'>buf</a>               387 usertests.c      if(read(pfds[0], buf, sizeof(buf)) != 1){</span>
<span class='curline'><a href='../S/96.html#L468'>buf</a>               468 usertests.c      char buf[10];</span>
<span class='curline'><a href='../S/96.html#L479'>buf</a>               479 usertests.c      memset(buf, pid==0?'c':'p', sizeof(buf));</span>
<span class='curline'><a href='../S/96.html#L481'>buf</a>               481 usertests.c        if(write(fd, buf, sizeof(buf)) != sizeof(buf)){</span>
<span class='curline'><a href='../S/96.html#L497'>buf</a>               497 usertests.c      while((n = read(fd, buf, sizeof(buf))) &gt; 0){</span>
<span class='curline'><a href='../S/96.html#L498'>buf</a>               498 usertests.c        for(i = 0; i &lt; sizeof(buf); i++){</span>
<span class='curline'><a href='../S/96.html#L499'>buf</a>               499 usertests.c          if(buf[i] == 'c')</span>
<span class='curline'><a href='../S/96.html#L501'>buf</a>               501 usertests.c          if(buf[i] == 'p')</span>
<span class='curline'><a href='../S/96.html#L543'>buf</a>               543 usertests.c          memset(buf, '0'+pi, 512);</span>
<span class='curline'><a href='../S/96.html#L545'>buf</a>               545 usertests.c            if((n = write(fd, buf, 500)) != 500){</span>
<span class='curline'><a href='../S/96.html#L562'>buf</a>               562 usertests.c        while((n = read(fd, buf, sizeof(buf))) &gt; 0){</span>
<span class='curline'><a href='../S/96.html#L564'>buf</a>               564 usertests.c            if(buf[j] != '0'+i){</span>
<span class='curline'><a href='../S/96.html#L684'>buf</a>               684 usertests.c      if(read(fd, buf, sizeof(buf)) != 5){</span>
<span class='curline'><a href='../S/96.html#L688'>buf</a>               688 usertests.c      if(buf[0] != 'h'){</span>
<span class='curline'><a href='../S/96.html#L692'>buf</a>               692 usertests.c      if(write(fd, buf, 10) != 10){</span>
<span class='curline'><a href='../S/96.html#L738'>buf</a>               738 usertests.c      if(read(fd, buf, sizeof(buf)) != 5){</span>
<span class='curline'><a href='../S/96.html#L978'>buf</a>               978 usertests.c      cc = read(fd, buf, sizeof(buf));</span>
<span class='curline'><a href='../S/96.html#L979'>buf</a>               979 usertests.c      if(cc != 2 || buf[0] != 'f'){</span>
<span class='curline'><a href='../S/96.html#L1021'>buf</a>              1021 usertests.c      if(read(fd, buf, sizeof(buf)) != 2){</span>
<span class='curline'><a href='../S/96.html#L1134'>buf</a>              1134 usertests.c          int cc = write(fd, buf, sz);</span>
<span class='curline'><a href='../S/96.html#L1161'>buf</a>              1161 usertests.c        memset(buf, i, 600);</span>
<span class='curline'><a href='../S/96.html#L1162'>buf</a>              1162 usertests.c        if(write(fd, buf, 600) != 600){</span>
<span class='curline'><a href='../S/96.html#L1176'>buf</a>              1176 usertests.c        cc = read(fd, buf, 300);</span>
<span class='curline'><a href='../S/96.html#L1187'>buf</a>              1187 usertests.c        if(buf[0] != i/2 || buf[299] != i/2){</span>
<span class='curline'><a href='../S/96.html#L1671'>buf</a>              1671 usertests.c          int cc = write(fd, buf, 512);</span>
<span class='curline'><a href='../S/22.html#L368'>buf</a>               368 vm.c             char *buf, *pa0;</span>
<span class='curline'><a href='../S/22.html#L371'>buf</a>               371 vm.c             buf = (char*)p;</span>
<span class='curline'><a href='../S/22.html#L380'>buf</a>               380 vm.c               memmove(pa0 + (va - va0), buf, n);</span>
<span class='curline'><a href='../S/22.html#L382'>buf</a>               382 vm.c               buf += n;</span>
<span class='curline'><a href='../S/36.html#L5'>buf</a>                 5 wc.c           char buf[512];</span>
<span class='curline'><a href='../S/36.html#L15'>buf</a>                15 wc.c             while((n = read(fd, buf, sizeof(buf))) &gt; 0){</span>
<span class='curline'><a href='../S/36.html#L18'>buf</a>                18 wc.c                 if(buf[i] == '\n')</span>
<span class='curline'><a href='../S/36.html#L20'>buf</a>                20 wc.c                 if(strchr(" \r\t\n\v", buf[i]))</span>
</pre>
</body>
</html>
