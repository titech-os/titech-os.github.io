<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>lk</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.5' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/56.html#L371'>lk</a>                371 proc.c         sleep(void *chan, struct spinlock *lk)</span>
<span class='curline'><a href='../S/56.html#L376'>lk</a>                376 proc.c           if(lk == 0)</span>
<span class='curline'><a href='../S/56.html#L385'>lk</a>                385 proc.c           if(lk != &amp;ptable.lock){  //DOC: sleeplock0</span>
<span class='curline'><a href='../S/56.html#L387'>lk</a>                387 proc.c             release(lk);</span>
<span class='curline'><a href='../S/56.html#L399'>lk</a>                399 proc.c           if(lk != &amp;ptable.lock){  //DOC: sleeplock2</span>
<span class='curline'><a href='../S/56.html#L401'>lk</a>                401 proc.c             acquire(lk);</span>
<span class='curline'><a href='../S/68.html#L14'>lk</a>                 14 sleeplock.c    initsleeplock(struct sleeplock *lk, char *name)</span>
<span class='curline'><a href='../S/68.html#L16'>lk</a>                 16 sleeplock.c      initlock(&amp;lk-&gt;lk, "sleep lock");</span>
<span class='curline'><a href='../S/68.html#L17'>lk</a>                 17 sleeplock.c      lk-&gt;name = name;</span>
<span class='curline'><a href='../S/68.html#L18'>lk</a>                 18 sleeplock.c      lk-&gt;locked = 0;</span>
<span class='curline'><a href='../S/68.html#L19'>lk</a>                 19 sleeplock.c      lk-&gt;pid = 0;</span>
<span class='curline'><a href='../S/68.html#L23'>lk</a>                 23 sleeplock.c    acquiresleep(struct sleeplock *lk)</span>
<span class='curline'><a href='../S/68.html#L25'>lk</a>                 25 sleeplock.c      acquire(&amp;lk-&gt;lk);</span>
<span class='curline'><a href='../S/68.html#L26'>lk</a>                 26 sleeplock.c      while (lk-&gt;locked) {</span>
<span class='curline'><a href='../S/68.html#L27'>lk</a>                 27 sleeplock.c        sleep(lk, &amp;lk-&gt;lk);</span>
<span class='curline'><a href='../S/68.html#L29'>lk</a>                 29 sleeplock.c      lk-&gt;locked = 1;</span>
<span class='curline'><a href='../S/68.html#L30'>lk</a>                 30 sleeplock.c      lk-&gt;pid = proc-&gt;pid;</span>
<span class='curline'><a href='../S/68.html#L31'>lk</a>                 31 sleeplock.c      release(&amp;lk-&gt;lk);</span>
<span class='curline'><a href='../S/68.html#L35'>lk</a>                 35 sleeplock.c    releasesleep(struct sleeplock *lk)</span>
<span class='curline'><a href='../S/68.html#L37'>lk</a>                 37 sleeplock.c      acquire(&amp;lk-&gt;lk);</span>
<span class='curline'><a href='../S/68.html#L38'>lk</a>                 38 sleeplock.c      lk-&gt;locked = 0;</span>
<span class='curline'><a href='../S/68.html#L39'>lk</a>                 39 sleeplock.c      lk-&gt;pid = 0;</span>
<span class='curline'><a href='../S/68.html#L40'>lk</a>                 40 sleeplock.c      wakeup(lk);</span>
<span class='curline'><a href='../S/68.html#L41'>lk</a>                 41 sleeplock.c      release(&amp;lk-&gt;lk);</span>
<span class='curline'><a href='../S/68.html#L45'>lk</a>                 45 sleeplock.c    holdingsleep(struct sleeplock *lk)</span>
<span class='curline'><a href='../S/68.html#L49'>lk</a>                 49 sleeplock.c      acquire(&amp;lk-&gt;lk);</span>
<span class='curline'><a href='../S/68.html#L50'>lk</a>                 50 sleeplock.c      r = lk-&gt;locked;</span>
<span class='curline'><a href='../S/68.html#L51'>lk</a>                 51 sleeplock.c      release(&amp;lk-&gt;lk);</span>
<span class='curline'><a href='../S/69.html#L4'>lk</a>                  4 sleeplock.h      struct spinlock lk; // spinlock protecting this sleep lock</span>
<span class='curline'><a href='../S/70.html#L13'>lk</a>                 13 spinlock.c     initlock(struct spinlock *lk, char *name)</span>
<span class='curline'><a href='../S/70.html#L15'>lk</a>                 15 spinlock.c       lk-&gt;name = name;</span>
<span class='curline'><a href='../S/70.html#L16'>lk</a>                 16 spinlock.c       lk-&gt;locked = 0;</span>
<span class='curline'><a href='../S/70.html#L17'>lk</a>                 17 spinlock.c       lk-&gt;cpu = 0;</span>
<span class='curline'><a href='../S/70.html#L25'>lk</a>                 25 spinlock.c     acquire(struct spinlock *lk)</span>
<span class='curline'><a href='../S/70.html#L28'>lk</a>                 28 spinlock.c       if(holding(lk))</span>
<span class='curline'><a href='../S/70.html#L32'>lk</a>                 32 spinlock.c       while(xchg(&amp;lk-&gt;locked, 1) != 0)</span>
<span class='curline'><a href='../S/70.html#L41'>lk</a>                 41 spinlock.c       lk-&gt;cpu = cpu;</span>
<span class='curline'><a href='../S/70.html#L42'>lk</a>                 42 spinlock.c       getcallerpcs(&amp;lk, lk-&gt;pcs);</span>
<span class='curline'><a href='../S/70.html#L47'>lk</a>                 47 spinlock.c     release(struct spinlock *lk)</span>
<span class='curline'><a href='../S/70.html#L49'>lk</a>                 49 spinlock.c       if(!holding(lk))</span>
<span class='curline'><a href='../S/70.html#L52'>lk</a>                 52 spinlock.c       lk-&gt;pcs[0] = 0;</span>
<span class='curline'><a href='../S/70.html#L53'>lk</a>                 53 spinlock.c       lk-&gt;cpu = 0;</span>
<span class='curline'><a href='../S/70.html#L65'>lk</a>                 65 spinlock.c       asm volatile("movl $0, %0" : "+m" (lk-&gt;locked) : );</span>
</pre>
</body>
</html>
