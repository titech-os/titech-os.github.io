<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>p</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.7' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/44.html#L14'>p</a>                  14 grep.c           char *p, *q;</span>
<span class='curline'><a href='../S/44.html#L20'>p</a>                  20 grep.c             p = buf;</span>
<span class='curline'><a href='../S/44.html#L21'>p</a>                  21 grep.c             while((q = strchr(p, '\n')) != 0){</span>
<span class='curline'><a href='../S/44.html#L23'>p</a>                  23 grep.c               if(match(pattern, p)){</span>
<span class='curline'><a href='../S/44.html#L25'>p</a>                  25 grep.c                 write(1, p, q+1 - p);</span>
<span class='curline'><a href='../S/44.html#L27'>p</a>                  27 grep.c               p = q+1;</span>
<span class='curline'><a href='../S/44.html#L29'>p</a>                  29 grep.c             if(p == buf)</span>
<span class='curline'><a href='../S/44.html#L32'>p</a>                  32 grep.c               m -= p - buf;</span>
<span class='curline'><a href='../S/44.html#L33'>p</a>                  33 grep.c               memmove(buf, p, m);</span>
<span class='curline'><a href='../S/58.html#L49'>p</a>                  49 kalloc.c         char *p;</span>
<span class='curline'><a href='../S/58.html#L50'>p</a>                  50 kalloc.c         p = (char*)PGROUNDUP((uint)vstart);</span>
<span class='curline'><a href='../S/58.html#L51'>p</a>                  51 kalloc.c         for(; p + PGSIZE &lt;= (char*)vend; p += PGSIZE)</span>
<span class='curline'><a href='../S/58.html#L52'>p</a>                  52 kalloc.c           kfree(p);</span>
<span class='curline'><a href='../S/80.html#L10'>p</a>                  10 ls.c             char *p;</span>
<span class='curline'><a href='../S/80.html#L13'>p</a>                  13 ls.c             for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--)</span>
<span class='curline'><a href='../S/80.html#L15'>p</a>                  15 ls.c             p++;</span>
<span class='curline'><a href='../S/80.html#L18'>p</a>                  18 ls.c             if(strlen(p) &gt;= DIRSIZ)</span>
<span class='curline'><a href='../S/80.html#L19'>p</a>                  19 ls.c               return p;</span>
<span class='curline'><a href='../S/80.html#L20'>p</a>                  20 ls.c             memmove(buf, p, strlen(p));</span>
<span class='curline'><a href='../S/80.html#L21'>p</a>                  21 ls.c             memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));</span>
<span class='curline'><a href='../S/80.html#L28'>p</a>                  28 ls.c             char buf[512], *p;</span>
<span class='curline'><a href='../S/80.html#L55'>p</a>                  55 ls.c               p = buf+strlen(buf);</span>
<span class='curline'><a href='../S/80.html#L56'>p</a>                  56 ls.c               *p++ = '/';</span>
<span class='curline'><a href='../S/80.html#L60'>p</a>                  60 ls.c                 memmove(p, de.name, DIRSIZ);</span>
<span class='curline'><a href='../S/80.html#L61'>p</a>                  61 ls.c                 p[DIRSIZ] = 0;</span>
<span class='curline'><a href='../S/86.html#L41'>p</a>                  41 memide.c         uchar *p;</span>
<span class='curline'><a href='../S/86.html#L52'>p</a>                  52 memide.c         p = memdisk + b-&gt;blockno*BSIZE;</span>
<span class='curline'><a href='../S/86.html#L56'>p</a>                  56 memide.c           memmove(p, b-&gt;data, BSIZE);</span>
<span class='curline'><a href='../S/86.html#L58'>p</a>                  58 memide.c           memmove(b-&gt;data, p, BSIZE);</span>
<span class='curline'><a href='../S/92.html#L42'>p</a>                  42 mkfs.c         void iappend(uint inum, void *p, int n);</span>
<span class='curline'><a href='../S/92.html#L258'>p</a>                 258 mkfs.c           char *p = (char*)xp;</span>
<span class='curline'><a href='../S/92.html#L289'>p</a>                 289 mkfs.c             bcopy(p, buf + off - (fbn * BSIZE), n1);</span>
<span class='curline'><a href='../S/92.html#L293'>p</a>                 293 mkfs.c             p += n1;</span>
<span class='curline'><a href='../S/93.html#L61'>p</a>                  61 mmu.h            uint p : 1;          // Present</span>
<span class='curline'><a href='../S/93.html#L203'>p</a>                 203 mmu.h            uint p : 1;           // Present</span>
<span class='curline'><a href='../S/93.html#L224'>p</a>                 224 mmu.h            (gate).p = 1;                                           \</span>
<span class='curline'><a href='../S/94.html#L33'>p</a>                  33 mp.c             uchar *e, *p, *addr;</span>
<span class='curline'><a href='../S/94.html#L37'>p</a>                  37 mp.c             for(p = addr; p &lt; e; p += sizeof(struct mp))</span>
<span class='curline'><a href='../S/94.html#L38'>p</a>                  38 mp.c               if(memcmp(p, "_MP_", 4) == 0 &amp;&amp; sum(p, sizeof(struct mp)) == 0)</span>
<span class='curline'><a href='../S/94.html#L39'>p</a>                  39 mp.c                 return (struct mp*)p;</span>
<span class='curline'><a href='../S/94.html#L52'>p</a>                  52 mp.c             uint p;</span>
<span class='curline'><a href='../S/94.html#L56'>p</a>                  56 mp.c             if((p = ((bda[0x0F]&lt;&lt;8)| bda[0x0E]) &lt;&lt; 4)){</span>
<span class='curline'><a href='../S/94.html#L57'>p</a>                  57 mp.c               if((mp = mpsearch1(p, 1024)))</span>
<span class='curline'><a href='../S/94.html#L60'>p</a>                  60 mp.c               p = ((bda[0x14]&lt;&lt;8)|bda[0x13])*1024;</span>
<span class='curline'><a href='../S/94.html#L61'>p</a>                  61 mp.c               if((mp = mpsearch1(p-1024, 1024)))</span>
<span class='curline'><a href='../S/94.html#L94'>p</a>                  94 mp.c             uchar *p, *e;</span>
<span class='curline'><a href='../S/94.html#L105'>p</a>                 105 mp.c             for(p=(uchar*)(conf+1), e=(uchar*)conf+conf-&gt;length; p&lt;e; ){</span>
<span class='curline'><a href='../S/94.html#L106'>p</a>                 106 mp.c               switch(*p){</span>
<span class='curline'><a href='../S/94.html#L108'>p</a>                 108 mp.c                 proc = (struct mpproc*)p;</span>
<span class='curline'><a href='../S/94.html#L113'>p</a>                 113 mp.c                 p += sizeof(struct mpproc);</span>
<span class='curline'><a href='../S/94.html#L116'>p</a>                 116 mp.c                 ioapic = (struct mpioapic*)p;</span>
<span class='curline'><a href='../S/94.html#L118'>p</a>                 118 mp.c                 p += sizeof(struct mpioapic);</span>
<span class='curline'><a href='../S/94.html#L123'>p</a>                 123 mp.c                 p += 8;</span>
<span class='curline'><a href='../S/101.html#L25'>p</a>                  25 pipe.c           struct pipe *p;</span>
<span class='curline'><a href='../S/101.html#L27'>p</a>                  27 pipe.c           p = 0;</span>
<span class='curline'><a href='../S/101.html#L31'>p</a>                  31 pipe.c           if((p = (struct pipe*)kalloc()) == 0)</span>
<span class='curline'><a href='../S/101.html#L33'>p</a>                  33 pipe.c           p-&gt;readopen = 1;</span>
<span class='curline'><a href='../S/101.html#L34'>p</a>                  34 pipe.c           p-&gt;writeopen = 1;</span>
<span class='curline'><a href='../S/101.html#L35'>p</a>                  35 pipe.c           p-&gt;nwrite = 0;</span>
<span class='curline'><a href='../S/101.html#L36'>p</a>                  36 pipe.c           p-&gt;nread = 0;</span>
<span class='curline'><a href='../S/101.html#L37'>p</a>                  37 pipe.c           initlock(&amp;p-&gt;lock, "pipe");</span>
<span class='curline'><a href='../S/101.html#L41'>p</a>                  41 pipe.c           (*f0)-&gt;pipe = p;</span>
<span class='curline'><a href='../S/101.html#L45'>p</a>                  45 pipe.c           (*f1)-&gt;pipe = p;</span>
<span class='curline'><a href='../S/101.html#L50'>p</a>                  50 pipe.c           if(p)</span>
<span class='curline'><a href='../S/101.html#L51'>p</a>                  51 pipe.c             kfree((char*)p);</span>
<span class='curline'><a href='../S/101.html#L60'>p</a>                  60 pipe.c         pipeclose(struct pipe *p, int writable)</span>
<span class='curline'><a href='../S/101.html#L62'>p</a>                  62 pipe.c           acquire(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/101.html#L64'>p</a>                  64 pipe.c             p-&gt;writeopen = 0;</span>
<span class='curline'><a href='../S/101.html#L65'>p</a>                  65 pipe.c             wakeup(&amp;p-&gt;nread);</span>
<span class='curline'><a href='../S/101.html#L67'>p</a>                  67 pipe.c             p-&gt;readopen = 0;</span>
<span class='curline'><a href='../S/101.html#L68'>p</a>                  68 pipe.c             wakeup(&amp;p-&gt;nwrite);</span>
<span class='curline'><a href='../S/101.html#L70'>p</a>                  70 pipe.c           if(p-&gt;readopen == 0 &amp;&amp; p-&gt;writeopen == 0){</span>
<span class='curline'><a href='../S/101.html#L71'>p</a>                  71 pipe.c             release(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/101.html#L72'>p</a>                  72 pipe.c             kfree((char*)p);</span>
<span class='curline'><a href='../S/101.html#L74'>p</a>                  74 pipe.c             release(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/101.html#L79'>p</a>                  79 pipe.c         pipewrite(struct pipe *p, char *addr, int n)</span>
<span class='curline'><a href='../S/101.html#L83'>p</a>                  83 pipe.c           acquire(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/101.html#L85'>p</a>                  85 pipe.c             while(p-&gt;nwrite == p-&gt;nread + PIPESIZE){  //DOC: pipewrite-full</span>
<span class='curline'><a href='../S/101.html#L86'>p</a>                  86 pipe.c               if(p-&gt;readopen == 0 || myproc()-&gt;killed){</span>
<span class='curline'><a href='../S/101.html#L87'>p</a>                  87 pipe.c                 release(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/101.html#L90'>p</a>                  90 pipe.c               wakeup(&amp;p-&gt;nread);</span>
<span class='curline'><a href='../S/101.html#L91'>p</a>                  91 pipe.c               sleep(&amp;p-&gt;nwrite, &amp;p-&gt;lock);  //DOC: pipewrite-sleep</span>
<span class='curline'><a href='../S/101.html#L93'>p</a>                  93 pipe.c             p-&gt;data[p-&gt;nwrite++ % PIPESIZE] = addr[i];</span>
<span class='curline'><a href='../S/101.html#L95'>p</a>                  95 pipe.c           wakeup(&amp;p-&gt;nread);  //DOC: pipewrite-wakeup1</span>
<span class='curline'><a href='../S/101.html#L96'>p</a>                  96 pipe.c           release(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/101.html#L101'>p</a>                 101 pipe.c         piperead(struct pipe *p, char *addr, int n)</span>
<span class='curline'><a href='../S/101.html#L105'>p</a>                 105 pipe.c           acquire(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/101.html#L106'>p</a>                 106 pipe.c           while(p-&gt;nread == p-&gt;nwrite &amp;&amp; p-&gt;writeopen){  //DOC: pipe-empty</span>
<span class='curline'><a href='../S/101.html#L108'>p</a>                 108 pipe.c               release(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/101.html#L111'>p</a>                 111 pipe.c             sleep(&amp;p-&gt;nread, &amp;p-&gt;lock); //DOC: piperead-sleep</span>
<span class='curline'><a href='../S/101.html#L114'>p</a>                 114 pipe.c             if(p-&gt;nread == p-&gt;nwrite)</span>
<span class='curline'><a href='../S/101.html#L116'>p</a>                 116 pipe.c             addr[i] = p-&gt;data[p-&gt;nread++ % PIPESIZE];</span>
<span class='curline'><a href='../S/101.html#L118'>p</a>                 118 pipe.c           wakeup(&amp;p-&gt;nwrite);  //DOC: piperead-wakeup</span>
<span class='curline'><a href='../S/101.html#L119'>p</a>                 119 pipe.c           release(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/107.html#L60'>p</a>                  60 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/107.html#L63'>p</a>                  63 proc.c           p = c-&gt;proc;</span>
<span class='curline'><a href='../S/107.html#L65'>p</a>                  65 proc.c           return p;</span>
<span class='curline'><a href='../S/107.html#L76'>p</a>                  76 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/107.html#L81'>p</a>                  81 proc.c           for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span>
<span class='curline'><a href='../S/107.html#L82'>p</a>                  82 proc.c             if(p-&gt;state == UNUSED)</span>
<span class='curline'><a href='../S/107.html#L89'>p</a>                  89 proc.c           p-&gt;state = EMBRYO;</span>
<span class='curline'><a href='../S/107.html#L90'>p</a>                  90 proc.c           p-&gt;pid = nextpid++;</span>
<span class='curline'><a href='../S/107.html#L95'>p</a>                  95 proc.c           if((p-&gt;kstack = kalloc()) == 0){</span>
<span class='curline'><a href='../S/107.html#L96'>p</a>                  96 proc.c             p-&gt;state = UNUSED;</span>
<span class='curline'><a href='../S/107.html#L99'>p</a>                  99 proc.c           sp = p-&gt;kstack + KSTACKSIZE;</span>
<span class='curline'><a href='../S/107.html#L102'>p</a>                 102 proc.c           sp -= sizeof *p-&gt;tf;</span>
<span class='curline'><a href='../S/107.html#L103'>p</a>                 103 proc.c           p-&gt;tf = (struct trapframe*)sp;</span>
<span class='curline'><a href='../S/107.html#L110'>p</a>                 110 proc.c           sp -= sizeof *p-&gt;context;</span>
<span class='curline'><a href='../S/107.html#L111'>p</a>                 111 proc.c           p-&gt;context = (struct context*)sp;</span>
<span class='curline'><a href='../S/107.html#L112'>p</a>                 112 proc.c           memset(p-&gt;context, 0, sizeof *p-&gt;context);</span>
<span class='curline'><a href='../S/107.html#L113'>p</a>                 113 proc.c           p-&gt;context-&gt;eip = (uint)forkret;</span>
<span class='curline'><a href='../S/107.html#L115'>p</a>                 115 proc.c           return p;</span>
<span class='curline'><a href='../S/107.html#L123'>p</a>                 123 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/107.html#L126'>p</a>                 126 proc.c           p = allocproc();</span>
<span class='curline'><a href='../S/107.html#L128'>p</a>                 128 proc.c           initproc = p;</span>
<span class='curline'><a href='../S/107.html#L129'>p</a>                 129 proc.c           if((p-&gt;pgdir = setupkvm()) == 0)</span>
<span class='curline'><a href='../S/107.html#L131'>p</a>                 131 proc.c           inituvm(p-&gt;pgdir, _binary_initcode_start, (int)_binary_initcode_size);</span>
<span class='curline'><a href='../S/107.html#L132'>p</a>                 132 proc.c           p-&gt;sz = PGSIZE;</span>
<span class='curline'><a href='../S/107.html#L133'>p</a>                 133 proc.c           memset(p-&gt;tf, 0, sizeof(*p-&gt;tf));</span>
<span class='curline'><a href='../S/107.html#L134'>p</a>                 134 proc.c           p-&gt;tf-&gt;cs = (SEG_UCODE &lt;&lt; 3) | DPL_USER;</span>
<span class='curline'><a href='../S/107.html#L135'>p</a>                 135 proc.c           p-&gt;tf-&gt;ds = (SEG_UDATA &lt;&lt; 3) | DPL_USER;</span>
<span class='curline'><a href='../S/107.html#L136'>p</a>                 136 proc.c           p-&gt;tf-&gt;es = p-&gt;tf-&gt;ds;</span>
<span class='curline'><a href='../S/107.html#L137'>p</a>                 137 proc.c           p-&gt;tf-&gt;ss = p-&gt;tf-&gt;ds;</span>
<span class='curline'><a href='../S/107.html#L138'>p</a>                 138 proc.c           p-&gt;tf-&gt;eflags = FL_IF;</span>
<span class='curline'><a href='../S/107.html#L139'>p</a>                 139 proc.c           p-&gt;tf-&gt;esp = PGSIZE;</span>
<span class='curline'><a href='../S/107.html#L140'>p</a>                 140 proc.c           p-&gt;tf-&gt;eip = 0;  // beginning of initcode.S</span>
<span class='curline'><a href='../S/107.html#L142'>p</a>                 142 proc.c           safestrcpy(p-&gt;name, "initcode", sizeof(p-&gt;name));</span>
<span class='curline'><a href='../S/107.html#L143'>p</a>                 143 proc.c           p-&gt;cwd = namei("/");</span>
<span class='curline'><a href='../S/107.html#L151'>p</a>                 151 proc.c           p-&gt;state = RUNNABLE;</span>
<span class='curline'><a href='../S/107.html#L231'>p</a>                 231 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/107.html#L256'>p</a>                 256 proc.c           for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span>
<span class='curline'><a href='../S/107.html#L257'>p</a>                 257 proc.c             if(p-&gt;parent == curproc){</span>
<span class='curline'><a href='../S/107.html#L258'>p</a>                 258 proc.c               p-&gt;parent = initproc;</span>
<span class='curline'><a href='../S/107.html#L259'>p</a>                 259 proc.c               if(p-&gt;state == ZOMBIE)</span>
<span class='curline'><a href='../S/107.html#L275'>p</a>                 275 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/107.html#L283'>p</a>                 283 proc.c             for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span>
<span class='curline'><a href='../S/107.html#L284'>p</a>                 284 proc.c               if(p-&gt;parent != curproc)</span>
<span class='curline'><a href='../S/107.html#L287'>p</a>                 287 proc.c               if(p-&gt;state == ZOMBIE){</span>
<span class='curline'><a href='../S/107.html#L289'>p</a>                 289 proc.c                 pid = p-&gt;pid;</span>
<span class='curline'><a href='../S/107.html#L290'>p</a>                 290 proc.c                 kfree(p-&gt;kstack);</span>
<span class='curline'><a href='../S/107.html#L291'>p</a>                 291 proc.c                 p-&gt;kstack = 0;</span>
<span class='curline'><a href='../S/107.html#L292'>p</a>                 292 proc.c                 freevm(p-&gt;pgdir);</span>
<span class='curline'><a href='../S/107.html#L293'>p</a>                 293 proc.c                 p-&gt;pid = 0;</span>
<span class='curline'><a href='../S/107.html#L294'>p</a>                 294 proc.c                 p-&gt;parent = 0;</span>
<span class='curline'><a href='../S/107.html#L295'>p</a>                 295 proc.c                 p-&gt;name[0] = 0;</span>
<span class='curline'><a href='../S/107.html#L296'>p</a>                 296 proc.c                 p-&gt;killed = 0;</span>
<span class='curline'><a href='../S/107.html#L297'>p</a>                 297 proc.c                 p-&gt;state = UNUSED;</span>
<span class='curline'><a href='../S/107.html#L325'>p</a>                 325 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/107.html#L335'>p</a>                 335 proc.c             for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span>
<span class='curline'><a href='../S/107.html#L336'>p</a>                 336 proc.c               if(p-&gt;state != RUNNABLE)</span>
<span class='curline'><a href='../S/107.html#L342'>p</a>                 342 proc.c               c-&gt;proc = p;</span>
<span class='curline'><a href='../S/107.html#L343'>p</a>                 343 proc.c               switchuvm(p);</span>
<span class='curline'><a href='../S/107.html#L344'>p</a>                 344 proc.c               p-&gt;state = RUNNING;</span>
<span class='curline'><a href='../S/107.html#L346'>p</a>                 346 proc.c               swtch(&amp;(c-&gt;scheduler), p-&gt;context);</span>
<span class='curline'><a href='../S/107.html#L369'>p</a>                 369 proc.c           struct proc *p = myproc();</span>
<span class='curline'><a href='../S/107.html#L375'>p</a>                 375 proc.c           if(p-&gt;state == RUNNING)</span>
<span class='curline'><a href='../S/107.html#L380'>p</a>                 380 proc.c           swtch(&amp;p-&gt;context, mycpu()-&gt;scheduler);</span>
<span class='curline'><a href='../S/107.html#L420'>p</a>                 420 proc.c           struct proc *p = myproc();</span>
<span class='curline'><a href='../S/107.html#L422'>p</a>                 422 proc.c           if(p == 0)</span>
<span class='curline'><a href='../S/107.html#L439'>p</a>                 439 proc.c           p-&gt;chan = chan;</span>
<span class='curline'><a href='../S/107.html#L440'>p</a>                 440 proc.c           p-&gt;state = SLEEPING;</span>
<span class='curline'><a href='../S/107.html#L445'>p</a>                 445 proc.c           p-&gt;chan = 0;</span>
<span class='curline'><a href='../S/107.html#L460'>p</a>                 460 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/107.html#L462'>p</a>                 462 proc.c           for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span>
<span class='curline'><a href='../S/107.html#L463'>p</a>                 463 proc.c             if(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan)</span>
<span class='curline'><a href='../S/107.html#L464'>p</a>                 464 proc.c               p-&gt;state = RUNNABLE;</span>
<span class='curline'><a href='../S/107.html#L482'>p</a>                 482 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/107.html#L485'>p</a>                 485 proc.c           for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span>
<span class='curline'><a href='../S/107.html#L486'>p</a>                 486 proc.c             if(p-&gt;pid == pid){</span>
<span class='curline'><a href='../S/107.html#L487'>p</a>                 487 proc.c               p-&gt;killed = 1;</span>
<span class='curline'><a href='../S/107.html#L489'>p</a>                 489 proc.c               if(p-&gt;state == SLEEPING)</span>
<span class='curline'><a href='../S/107.html#L490'>p</a>                 490 proc.c                 p-&gt;state = RUNNABLE;</span>
<span class='curline'><a href='../S/107.html#L515'>p</a>                 515 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/107.html#L519'>p</a>                 519 proc.c           for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span>
<span class='curline'><a href='../S/107.html#L520'>p</a>                 520 proc.c             if(p-&gt;state == UNUSED)</span>
<span class='curline'><a href='../S/107.html#L522'>p</a>                 522 proc.c             if(p-&gt;state &gt;= 0 &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state])</span>
<span class='curline'><a href='../S/107.html#L523'>p</a>                 523 proc.c               state = states[p-&gt;state];</span>
<span class='curline'><a href='../S/107.html#L526'>p</a>                 526 proc.c             cprintf("%d %s %s", p-&gt;pid, state, p-&gt;name);</span>
<span class='curline'><a href='../S/107.html#L527'>p</a>                 527 proc.c             if(p-&gt;state == SLEEPING){</span>
<span class='curline'><a href='../S/107.html#L528'>p</a>                 528 proc.c               getcallerpcs((uint*)p-&gt;context-&gt;ebp+2, pc);</span>
<span class='curline'><a href='../S/120.html#L60'>p</a>                  60 sh.c             int p[2];</span>
<span class='curline'><a href='../S/120.html#L102'>p</a>                 102 sh.c               if(pipe(p) &lt; 0)</span>
<span class='curline'><a href='../S/120.html#L106'>p</a>                 106 sh.c                 dup(p[1]);</span>
<span class='curline'><a href='../S/120.html#L107'>p</a>                 107 sh.c                 close(p[0]);</span>
<span class='curline'><a href='../S/120.html#L108'>p</a>                 108 sh.c                 close(p[1]);</span>
<span class='curline'><a href='../S/120.html#L113'>p</a>                 113 sh.c                 dup(p[0]);</span>
<span class='curline'><a href='../S/120.html#L114'>p</a>                 114 sh.c                 close(p[0]);</span>
<span class='curline'><a href='../S/120.html#L115'>p</a>                 115 sh.c                 close(p[1]);</span>
<span class='curline'><a href='../S/120.html#L118'>p</a>                 118 sh.c               close(p[0]);</span>
<span class='curline'><a href='../S/120.html#L119'>p</a>                 119 sh.c               close(p[1]);</span>
<span class='curline'><a href='../S/138.html#L59'>p</a>                  59 string.c       strncmp(const char *p, const char *q, uint n)</span>
<span class='curline'><a href='../S/138.html#L61'>p</a>                  61 string.c         while(n &gt; 0 &amp;&amp; *p &amp;&amp; *p == *q)</span>
<span class='curline'><a href='../S/138.html#L62'>p</a>                  62 string.c           n--, p++, q++;</span>
<span class='curline'><a href='../S/138.html#L65'>p</a>                  65 string.c         return (uchar)*p - (uchar)*q;</span>
<span class='curline'><a href='../S/145.html#L74'>p</a>                  74 sysfile.c        char *p;</span>
<span class='curline'><a href='../S/145.html#L76'>p</a>                  76 sysfile.c        if(argfd(0, 0, &amp;f) &lt; 0 || argint(2, &amp;n) &lt; 0 || argptr(1, &amp;p, n) &lt; 0)</span>
<span class='curline'><a href='../S/145.html#L78'>p</a>                  78 sysfile.c        return fileread(f, p, n);</span>
<span class='curline'><a href='../S/145.html#L86'>p</a>                  86 sysfile.c        char *p;</span>
<span class='curline'><a href='../S/145.html#L88'>p</a>                  88 sysfile.c        if(argfd(0, 0, &amp;f) &lt; 0 || argint(2, &amp;n) &lt; 0 || argptr(1, &amp;p, n) &lt; 0)</span>
<span class='curline'><a href='../S/145.html#L90'>p</a>                  90 sysfile.c        return filewrite(f, p, n);</span>
<span class='curline'><a href='../S/157.html#L22'>p</a>                  22 uart.c           char *p;</span>
<span class='curline'><a href='../S/157.html#L47'>p</a>                  47 uart.c           for(p="xv6...\n"; *p; p++)</span>
<span class='curline'><a href='../S/157.html#L48'>p</a>                  48 uart.c             uartputc(*p);</span>
<span class='curline'><a href='../S/159.html#L19'>p</a>                  19 ulib.c         strcmp(const char *p, const char *q)</span>
<span class='curline'><a href='../S/159.html#L21'>p</a>                  21 ulib.c           while(*p &amp;&amp; *p == *q)</span>
<span class='curline'><a href='../S/159.html#L22'>p</a>                  22 ulib.c             p++, q++;</span>
<span class='curline'><a href='../S/159.html#L23'>p</a>                  23 ulib.c           return (uchar)*p - (uchar)*q;</span>
<span class='curline'><a href='../S/161.html#L27'>p</a>                  27 umalloc.c        Header *bp, *p;</span>
<span class='curline'><a href='../S/161.html#L30'>p</a>                  30 umalloc.c        for(p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr); p = p-&gt;s.ptr)</span>
<span class='curline'><a href='../S/161.html#L31'>p</a>                  31 umalloc.c          if(p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr))</span>
<span class='curline'><a href='../S/161.html#L33'>p</a>                  33 umalloc.c        if(bp + bp-&gt;s.size == p-&gt;s.ptr){</span>
<span class='curline'><a href='../S/161.html#L34'>p</a>                  34 umalloc.c          bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;</span>
<span class='curline'><a href='../S/161.html#L35'>p</a>                  35 umalloc.c          bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;</span>
<span class='curline'><a href='../S/161.html#L37'>p</a>                  37 umalloc.c          bp-&gt;s.ptr = p-&gt;s.ptr;</span>
<span class='curline'><a href='../S/161.html#L38'>p</a>                  38 umalloc.c        if(p + p-&gt;s.size == bp){</span>
<span class='curline'><a href='../S/161.html#L39'>p</a>                  39 umalloc.c          p-&gt;s.size += bp-&gt;s.size;</span>
<span class='curline'><a href='../S/161.html#L40'>p</a>                  40 umalloc.c          p-&gt;s.ptr = bp-&gt;s.ptr;</span>
<span class='curline'><a href='../S/161.html#L42'>p</a>                  42 umalloc.c          p-&gt;s.ptr = bp;</span>
<span class='curline'><a href='../S/161.html#L43'>p</a>                  43 umalloc.c        freep = p;</span>
<span class='curline'><a href='../S/161.html#L49'>p</a>                  49 umalloc.c        char *p;</span>
<span class='curline'><a href='../S/161.html#L54'>p</a>                  54 umalloc.c        p = sbrk(nu * sizeof(Header));</span>
<span class='curline'><a href='../S/161.html#L55'>p</a>                  55 umalloc.c        if(p == (char*)-1)</span>
<span class='curline'><a href='../S/161.html#L57'>p</a>                  57 umalloc.c        hp = (Header*)p;</span>
<span class='curline'><a href='../S/161.html#L66'>p</a>                  66 umalloc.c        Header *p, *prevp;</span>
<span class='curline'><a href='../S/161.html#L74'>p</a>                  74 umalloc.c        for(p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr){</span>
<span class='curline'><a href='../S/161.html#L75'>p</a>                  75 umalloc.c          if(p-&gt;s.size &gt;= nunits){</span>
<span class='curline'><a href='../S/161.html#L76'>p</a>                  76 umalloc.c            if(p-&gt;s.size == nunits)</span>
<span class='curline'><a href='../S/161.html#L77'>p</a>                  77 umalloc.c              prevp-&gt;s.ptr = p-&gt;s.ptr;</span>
<span class='curline'><a href='../S/161.html#L79'>p</a>                  79 umalloc.c              p-&gt;s.size -= nunits;</span>
<span class='curline'><a href='../S/161.html#L80'>p</a>                  80 umalloc.c              p += p-&gt;s.size;</span>
<span class='curline'><a href='../S/161.html#L81'>p</a>                  81 umalloc.c              p-&gt;s.size = nunits;</span>
<span class='curline'><a href='../S/161.html#L84'>p</a>                  84 umalloc.c            return (void*)(p + 1);</span>
<span class='curline'><a href='../S/161.html#L86'>p</a>                  86 umalloc.c          if(p == freep)</span>
<span class='curline'><a href='../S/161.html#L87'>p</a>                  87 umalloc.c            if((p = morecore(nunits)) == 0)</span>
<span class='curline'><a href='../S/165.html#L1418'>p</a>                1418 usertests.c      char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;</span>
<span class='curline'><a href='../S/165.html#L1455'>p</a>                1455 usertests.c      p = sbrk(amt);</span>
<span class='curline'><a href='../S/165.html#L1456'>p</a>                1456 usertests.c      if (p != a) {</span>
<span class='curline'><a href='../S/165.html#L1550'>p</a>                1550 usertests.c    validateint(int *p)</span>
<span class='curline'><a href='../S/165.html#L1558'>p</a>                1558 usertests.c          "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :</span>
<span class='curline'><a href='../S/165.html#L1566'>p</a>                1566 usertests.c      uint p;</span>
<span class='curline'><a href='../S/165.html#L1571'>p</a>                1571 usertests.c      for(p = 0; p &lt;= (uint)hi; p += 4096){</span>
<span class='curline'><a href='../S/165.html#L1574'>p</a>                1574 usertests.c          validateint((int*)p);</span>
<span class='curline'><a href='../S/165.html#L1583'>p</a>                1583 usertests.c        if(link("nosuchfile", (char*)p) != -1){</span>
<span class='curline'><a href='../S/171.html#L157'>p</a>                 157 vm.c           switchuvm(struct proc *p)</span>
<span class='curline'><a href='../S/171.html#L159'>p</a>                 159 vm.c             if(p == 0)</span>
<span class='curline'><a href='../S/171.html#L161'>p</a>                 161 vm.c             if(p-&gt;kstack == 0)</span>
<span class='curline'><a href='../S/171.html#L163'>p</a>                 163 vm.c             if(p-&gt;pgdir == 0)</span>
<span class='curline'><a href='../S/171.html#L171'>p</a>                 171 vm.c             mycpu()-&gt;ts.esp0 = (uint)p-&gt;kstack + KSTACKSIZE;</span>
<span class='curline'><a href='../S/171.html#L176'>p</a>                 176 vm.c             lcr3(V2P(p-&gt;pgdir));  // switch to process's address space</span>
<span class='curline'><a href='../S/171.html#L364'>p</a>                 364 vm.c           copyout(pde_t *pgdir, uint va, void *p, uint len)</span>
<span class='curline'><a href='../S/171.html#L369'>p</a>                 369 vm.c             buf = (char*)p;</span>
<span class='curline'><a href='../S/177.html#L63'>p</a>                  63 x86.h          lgdt(struct segdesc *p, int size)</span>
<span class='curline'><a href='../S/177.html#L68'>p</a>                  68 x86.h            pd[1] = (uint)p;</span>
<span class='curline'><a href='../S/177.html#L69'>p</a>                  69 x86.h            pd[2] = (uint)p &gt;&gt; 16;</span>
<span class='curline'><a href='../S/177.html#L77'>p</a>                  77 x86.h          lidt(struct gatedesc *p, int size)</span>
<span class='curline'><a href='../S/177.html#L82'>p</a>                  82 x86.h            pd[1] = (uint)p;</span>
<span class='curline'><a href='../S/177.html#L83'>p</a>                  83 x86.h            pd[2] = (uint)p &gt;&gt; 16;</span>
</pre>
</body>
</html>
