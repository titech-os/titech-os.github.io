<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>p</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.1' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/25.html#L14'>p</a>                  14 grep.c           char *p, *q;</span>
<span class='curline'><a href='../S/25.html#L20'>p</a>                  20 grep.c             p = buf;</span>
<span class='curline'><a href='../S/25.html#L21'>p</a>                  21 grep.c             while((q = strchr(p, '\n')) != 0){</span>
<span class='curline'><a href='../S/25.html#L23'>p</a>                  23 grep.c               if(match(pattern, p)){</span>
<span class='curline'><a href='../S/25.html#L25'>p</a>                  25 grep.c                 write(1, p, q+1 - p);</span>
<span class='curline'><a href='../S/25.html#L27'>p</a>                  27 grep.c               p = q+1;</span>
<span class='curline'><a href='../S/25.html#L29'>p</a>                  29 grep.c             if(p == buf)</span>
<span class='curline'><a href='../S/25.html#L32'>p</a>                  32 grep.c               m -= p - buf;</span>
<span class='curline'><a href='../S/25.html#L33'>p</a>                  33 grep.c               memmove(buf, p, m);</span>
<span class='curline'><a href='../S/30.html#L48'>p</a>                  48 kalloc.c         char *p;</span>
<span class='curline'><a href='../S/30.html#L49'>p</a>                  49 kalloc.c         p = (char*)PGROUNDUP((uint)vstart);</span>
<span class='curline'><a href='../S/30.html#L50'>p</a>                  50 kalloc.c         for(; p + PGSIZE &lt;= (char*)vend; p += PGSIZE)</span>
<span class='curline'><a href='../S/30.html#L51'>p</a>                  51 kalloc.c           kfree(p);</span>
<span class='curline'><a href='../S/39.html#L10'>p</a>                  10 ls.c             char *p;</span>
<span class='curline'><a href='../S/39.html#L13'>p</a>                  13 ls.c             for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--)</span>
<span class='curline'><a href='../S/39.html#L15'>p</a>                  15 ls.c             p++;</span>
<span class='curline'><a href='../S/39.html#L18'>p</a>                  18 ls.c             if(strlen(p) &gt;= DIRSIZ)</span>
<span class='curline'><a href='../S/39.html#L19'>p</a>                  19 ls.c               return p;</span>
<span class='curline'><a href='../S/39.html#L20'>p</a>                  20 ls.c             memmove(buf, p, strlen(p));</span>
<span class='curline'><a href='../S/39.html#L21'>p</a>                  21 ls.c             memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));</span>
<span class='curline'><a href='../S/39.html#L28'>p</a>                  28 ls.c             char buf[512], *p;</span>
<span class='curline'><a href='../S/39.html#L55'>p</a>                  55 ls.c               p = buf+strlen(buf);</span>
<span class='curline'><a href='../S/39.html#L56'>p</a>                  56 ls.c               *p++ = '/';</span>
<span class='curline'><a href='../S/39.html#L60'>p</a>                  60 ls.c                 memmove(p, de.name, DIRSIZ);</span>
<span class='curline'><a href='../S/39.html#L61'>p</a>                  61 ls.c                 p[DIRSIZ] = 0;</span>
<span class='curline'><a href='../S/42.html#L40'>p</a>                  40 memide.c         uchar *p;</span>
<span class='curline'><a href='../S/42.html#L51'>p</a>                  51 memide.c         p = memdisk + b-&gt;blockno*BSIZE;</span>
<span class='curline'><a href='../S/42.html#L55'>p</a>                  55 memide.c           memmove(p, b-&gt;data, BSIZE);</span>
<span class='curline'><a href='../S/42.html#L57'>p</a>                  57 memide.c           memmove(b-&gt;data, p, BSIZE);</span>
<span class='curline'><a href='../S/45.html#L42'>p</a>                  42 mkfs.c         void iappend(uint inum, void *p, int n);</span>
<span class='curline'><a href='../S/45.html#L258'>p</a>                 258 mkfs.c           char *p = (char*)xp;</span>
<span class='curline'><a href='../S/45.html#L289'>p</a>                 289 mkfs.c             bcopy(p, buf + off - (fbn * BSIZE), n1);</span>
<span class='curline'><a href='../S/45.html#L293'>p</a>                 293 mkfs.c             p += n1;</span>
<span class='curline'><a href='../S/46.html#L59'>p</a>                  59 mmu.h            uint p : 1;          // Present</span>
<span class='curline'><a href='../S/46.html#L201'>p</a>                 201 mmu.h            uint p : 1;           // Present</span>
<span class='curline'><a href='../S/46.html#L222'>p</a>                 222 mmu.h            (gate).p = 1;                                           \</span>
<span class='curline'><a href='../S/47.html#L41'>p</a>                  41 mp.c             uchar *e, *p, *addr;</span>
<span class='curline'><a href='../S/47.html#L45'>p</a>                  45 mp.c             for(p = addr; p &lt; e; p += sizeof(struct mp))</span>
<span class='curline'><a href='../S/47.html#L46'>p</a>                  46 mp.c               if(memcmp(p, "_MP_", 4) == 0 &amp;&amp; sum(p, sizeof(struct mp)) == 0)</span>
<span class='curline'><a href='../S/47.html#L47'>p</a>                  47 mp.c                 return (struct mp*)p;</span>
<span class='curline'><a href='../S/47.html#L60'>p</a>                  60 mp.c             uint p;</span>
<span class='curline'><a href='../S/47.html#L64'>p</a>                  64 mp.c             if((p = ((bda[0x0F]&lt;&lt;8)| bda[0x0E]) &lt;&lt; 4)){</span>
<span class='curline'><a href='../S/47.html#L65'>p</a>                  65 mp.c               if((mp = mpsearch1(p, 1024)))</span>
<span class='curline'><a href='../S/47.html#L68'>p</a>                  68 mp.c               p = ((bda[0x14]&lt;&lt;8)|bda[0x13])*1024;</span>
<span class='curline'><a href='../S/47.html#L69'>p</a>                  69 mp.c               if((mp = mpsearch1(p-1024, 1024)))</span>
<span class='curline'><a href='../S/47.html#L102'>p</a>                 102 mp.c             uchar *p, *e;</span>
<span class='curline'><a href='../S/47.html#L113'>p</a>                 113 mp.c             for(p=(uchar*)(conf+1), e=(uchar*)conf+conf-&gt;length; p&lt;e; ){</span>
<span class='curline'><a href='../S/47.html#L114'>p</a>                 114 mp.c               switch(*p){</span>
<span class='curline'><a href='../S/47.html#L116'>p</a>                 116 mp.c                 proc = (struct mpproc*)p;</span>
<span class='curline'><a href='../S/47.html#L125'>p</a>                 125 mp.c                 p += sizeof(struct mpproc);</span>
<span class='curline'><a href='../S/47.html#L128'>p</a>                 128 mp.c                 ioapic = (struct mpioapic*)p;</span>
<span class='curline'><a href='../S/47.html#L130'>p</a>                 130 mp.c                 p += sizeof(struct mpioapic);</span>
<span class='curline'><a href='../S/47.html#L135'>p</a>                 135 mp.c                 p += 8;</span>
<span class='curline'><a href='../S/47.html#L138'>p</a>                 138 mp.c                 cprintf("mpinit: unknown config type %x\n", *p);</span>
<span class='curline'><a href='../S/52.html#L24'>p</a>                  24 pipe.c           struct pipe *p;</span>
<span class='curline'><a href='../S/52.html#L26'>p</a>                  26 pipe.c           p = 0;</span>
<span class='curline'><a href='../S/52.html#L30'>p</a>                  30 pipe.c           if((p = (struct pipe*)kalloc()) == 0)</span>
<span class='curline'><a href='../S/52.html#L32'>p</a>                  32 pipe.c           p-&gt;readopen = 1;</span>
<span class='curline'><a href='../S/52.html#L33'>p</a>                  33 pipe.c           p-&gt;writeopen = 1;</span>
<span class='curline'><a href='../S/52.html#L34'>p</a>                  34 pipe.c           p-&gt;nwrite = 0;</span>
<span class='curline'><a href='../S/52.html#L35'>p</a>                  35 pipe.c           p-&gt;nread = 0;</span>
<span class='curline'><a href='../S/52.html#L36'>p</a>                  36 pipe.c           initlock(&amp;p-&gt;lock, "pipe");</span>
<span class='curline'><a href='../S/52.html#L40'>p</a>                  40 pipe.c           (*f0)-&gt;pipe = p;</span>
<span class='curline'><a href='../S/52.html#L44'>p</a>                  44 pipe.c           (*f1)-&gt;pipe = p;</span>
<span class='curline'><a href='../S/52.html#L49'>p</a>                  49 pipe.c           if(p)</span>
<span class='curline'><a href='../S/52.html#L50'>p</a>                  50 pipe.c             kfree((char*)p);</span>
<span class='curline'><a href='../S/52.html#L59'>p</a>                  59 pipe.c         pipeclose(struct pipe *p, int writable)</span>
<span class='curline'><a href='../S/52.html#L61'>p</a>                  61 pipe.c           acquire(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/52.html#L63'>p</a>                  63 pipe.c             p-&gt;writeopen = 0;</span>
<span class='curline'><a href='../S/52.html#L64'>p</a>                  64 pipe.c             wakeup(&amp;p-&gt;nread);</span>
<span class='curline'><a href='../S/52.html#L66'>p</a>                  66 pipe.c             p-&gt;readopen = 0;</span>
<span class='curline'><a href='../S/52.html#L67'>p</a>                  67 pipe.c             wakeup(&amp;p-&gt;nwrite);</span>
<span class='curline'><a href='../S/52.html#L69'>p</a>                  69 pipe.c           if(p-&gt;readopen == 0 &amp;&amp; p-&gt;writeopen == 0){</span>
<span class='curline'><a href='../S/52.html#L70'>p</a>                  70 pipe.c             release(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/52.html#L71'>p</a>                  71 pipe.c             kfree((char*)p);</span>
<span class='curline'><a href='../S/52.html#L73'>p</a>                  73 pipe.c             release(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/52.html#L78'>p</a>                  78 pipe.c         pipewrite(struct pipe *p, char *addr, int n)</span>
<span class='curline'><a href='../S/52.html#L82'>p</a>                  82 pipe.c           acquire(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/52.html#L84'>p</a>                  84 pipe.c             while(p-&gt;nwrite == p-&gt;nread + PIPESIZE){  //DOC: pipewrite-full</span>
<span class='curline'><a href='../S/52.html#L85'>p</a>                  85 pipe.c               if(p-&gt;readopen == 0 || proc-&gt;killed){</span>
<span class='curline'><a href='../S/52.html#L86'>p</a>                  86 pipe.c                 release(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/52.html#L89'>p</a>                  89 pipe.c               wakeup(&amp;p-&gt;nread);</span>
<span class='curline'><a href='../S/52.html#L90'>p</a>                  90 pipe.c               sleep(&amp;p-&gt;nwrite, &amp;p-&gt;lock);  //DOC: pipewrite-sleep</span>
<span class='curline'><a href='../S/52.html#L92'>p</a>                  92 pipe.c             p-&gt;data[p-&gt;nwrite++ % PIPESIZE] = addr[i];</span>
<span class='curline'><a href='../S/52.html#L94'>p</a>                  94 pipe.c           wakeup(&amp;p-&gt;nread);  //DOC: pipewrite-wakeup1</span>
<span class='curline'><a href='../S/52.html#L95'>p</a>                  95 pipe.c           release(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/52.html#L100'>p</a>                 100 pipe.c         piperead(struct pipe *p, char *addr, int n)</span>
<span class='curline'><a href='../S/52.html#L104'>p</a>                 104 pipe.c           acquire(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/52.html#L105'>p</a>                 105 pipe.c           while(p-&gt;nread == p-&gt;nwrite &amp;&amp; p-&gt;writeopen){  //DOC: pipe-empty</span>
<span class='curline'><a href='../S/52.html#L107'>p</a>                 107 pipe.c               release(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/52.html#L110'>p</a>                 110 pipe.c             sleep(&amp;p-&gt;nread, &amp;p-&gt;lock); //DOC: piperead-sleep</span>
<span class='curline'><a href='../S/52.html#L113'>p</a>                 113 pipe.c             if(p-&gt;nread == p-&gt;nwrite)</span>
<span class='curline'><a href='../S/52.html#L115'>p</a>                 115 pipe.c             addr[i] = p-&gt;data[p-&gt;nread++ % PIPESIZE];</span>
<span class='curline'><a href='../S/52.html#L117'>p</a>                 117 pipe.c           wakeup(&amp;p-&gt;nwrite);  //DOC: piperead-wakeup</span>
<span class='curline'><a href='../S/52.html#L118'>p</a>                 118 pipe.c           release(&amp;p-&gt;lock);</span>
<span class='curline'><a href='../S/56.html#L37'>p</a>                  37 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/56.html#L41'>p</a>                  41 proc.c           for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span>
<span class='curline'><a href='../S/56.html#L42'>p</a>                  42 proc.c             if(p-&gt;state == UNUSED)</span>
<span class='curline'><a href='../S/56.html#L48'>p</a>                  48 proc.c           p-&gt;state = EMBRYO;</span>
<span class='curline'><a href='../S/56.html#L49'>p</a>                  49 proc.c           p-&gt;pid = nextpid++;</span>
<span class='curline'><a href='../S/56.html#L53'>p</a>                  53 proc.c           if((p-&gt;kstack = kalloc()) == 0){</span>
<span class='curline'><a href='../S/56.html#L54'>p</a>                  54 proc.c             p-&gt;state = UNUSED;</span>
<span class='curline'><a href='../S/56.html#L57'>p</a>                  57 proc.c           sp = p-&gt;kstack + KSTACKSIZE;</span>
<span class='curline'><a href='../S/56.html#L60'>p</a>                  60 proc.c           sp -= sizeof *p-&gt;tf;</span>
<span class='curline'><a href='../S/56.html#L61'>p</a>                  61 proc.c           p-&gt;tf = (struct trapframe*)sp;</span>
<span class='curline'><a href='../S/56.html#L68'>p</a>                  68 proc.c           sp -= sizeof *p-&gt;context;</span>
<span class='curline'><a href='../S/56.html#L69'>p</a>                  69 proc.c           p-&gt;context = (struct context*)sp;</span>
<span class='curline'><a href='../S/56.html#L70'>p</a>                  70 proc.c           memset(p-&gt;context, 0, sizeof *p-&gt;context);</span>
<span class='curline'><a href='../S/56.html#L71'>p</a>                  71 proc.c           p-&gt;context-&gt;eip = (uint)forkret;</span>
<span class='curline'><a href='../S/56.html#L73'>p</a>                  73 proc.c           return p;</span>
<span class='curline'><a href='../S/56.html#L81'>p</a>                  81 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/56.html#L84'>p</a>                  84 proc.c           p = allocproc();</span>
<span class='curline'><a href='../S/56.html#L85'>p</a>                  85 proc.c           initproc = p;</span>
<span class='curline'><a href='../S/56.html#L86'>p</a>                  86 proc.c           if((p-&gt;pgdir = setupkvm()) == 0)</span>
<span class='curline'><a href='../S/56.html#L88'>p</a>                  88 proc.c           inituvm(p-&gt;pgdir, _binary_initcode_start, (int)_binary_initcode_size);</span>
<span class='curline'><a href='../S/56.html#L89'>p</a>                  89 proc.c           p-&gt;sz = PGSIZE;</span>
<span class='curline'><a href='../S/56.html#L90'>p</a>                  90 proc.c           memset(p-&gt;tf, 0, sizeof(*p-&gt;tf));</span>
<span class='curline'><a href='../S/56.html#L91'>p</a>                  91 proc.c           p-&gt;tf-&gt;cs = (SEG_UCODE &lt;&lt; 3) | DPL_USER;</span>
<span class='curline'><a href='../S/56.html#L92'>p</a>                  92 proc.c           p-&gt;tf-&gt;ds = (SEG_UDATA &lt;&lt; 3) | DPL_USER;</span>
<span class='curline'><a href='../S/56.html#L93'>p</a>                  93 proc.c           p-&gt;tf-&gt;es = p-&gt;tf-&gt;ds;</span>
<span class='curline'><a href='../S/56.html#L94'>p</a>                  94 proc.c           p-&gt;tf-&gt;ss = p-&gt;tf-&gt;ds;</span>
<span class='curline'><a href='../S/56.html#L95'>p</a>                  95 proc.c           p-&gt;tf-&gt;eflags = FL_IF;</span>
<span class='curline'><a href='../S/56.html#L96'>p</a>                  96 proc.c           p-&gt;tf-&gt;esp = PGSIZE;</span>
<span class='curline'><a href='../S/56.html#L97'>p</a>                  97 proc.c           p-&gt;tf-&gt;eip = 0;  // beginning of initcode.S</span>
<span class='curline'><a href='../S/56.html#L99'>p</a>                  99 proc.c           safestrcpy(p-&gt;name, "initcode", sizeof(p-&gt;name));</span>
<span class='curline'><a href='../S/56.html#L100'>p</a>                 100 proc.c           p-&gt;cwd = namei("/");</span>
<span class='curline'><a href='../S/56.html#L102'>p</a>                 102 proc.c           p-&gt;state = RUNNABLE;</span>
<span class='curline'><a href='../S/56.html#L175'>p</a>                 175 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/56.html#L200'>p</a>                 200 proc.c           for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span>
<span class='curline'><a href='../S/56.html#L201'>p</a>                 201 proc.c             if(p-&gt;parent == proc){</span>
<span class='curline'><a href='../S/56.html#L202'>p</a>                 202 proc.c               p-&gt;parent = initproc;</span>
<span class='curline'><a href='../S/56.html#L203'>p</a>                 203 proc.c               if(p-&gt;state == ZOMBIE)</span>
<span class='curline'><a href='../S/56.html#L219'>p</a>                 219 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/56.html#L226'>p</a>                 226 proc.c             for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span>
<span class='curline'><a href='../S/56.html#L227'>p</a>                 227 proc.c               if(p-&gt;parent != proc)</span>
<span class='curline'><a href='../S/56.html#L230'>p</a>                 230 proc.c               if(p-&gt;state == ZOMBIE){</span>
<span class='curline'><a href='../S/56.html#L232'>p</a>                 232 proc.c                 pid = p-&gt;pid;</span>
<span class='curline'><a href='../S/56.html#L233'>p</a>                 233 proc.c                 kfree(p-&gt;kstack);</span>
<span class='curline'><a href='../S/56.html#L234'>p</a>                 234 proc.c                 p-&gt;kstack = 0;</span>
<span class='curline'><a href='../S/56.html#L235'>p</a>                 235 proc.c                 freevm(p-&gt;pgdir);</span>
<span class='curline'><a href='../S/56.html#L236'>p</a>                 236 proc.c                 p-&gt;state = UNUSED;</span>
<span class='curline'><a href='../S/56.html#L237'>p</a>                 237 proc.c                 p-&gt;pid = 0;</span>
<span class='curline'><a href='../S/56.html#L238'>p</a>                 238 proc.c                 p-&gt;parent = 0;</span>
<span class='curline'><a href='../S/56.html#L239'>p</a>                 239 proc.c                 p-&gt;name[0] = 0;</span>
<span class='curline'><a href='../S/56.html#L240'>p</a>                 240 proc.c                 p-&gt;killed = 0;</span>
<span class='curline'><a href='../S/56.html#L268'>p</a>                 268 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/56.html#L276'>p</a>                 276 proc.c             for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span>
<span class='curline'><a href='../S/56.html#L277'>p</a>                 277 proc.c               if(p-&gt;state != RUNNABLE)</span>
<span class='curline'><a href='../S/56.html#L283'>p</a>                 283 proc.c               proc = p;</span>
<span class='curline'><a href='../S/56.html#L284'>p</a>                 284 proc.c               switchuvm(p);</span>
<span class='curline'><a href='../S/56.html#L285'>p</a>                 285 proc.c               p-&gt;state = RUNNING;</span>
<span class='curline'><a href='../S/56.html#L392'>p</a>                 392 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/56.html#L394'>p</a>                 394 proc.c           for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span>
<span class='curline'><a href='../S/56.html#L395'>p</a>                 395 proc.c             if(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan)</span>
<span class='curline'><a href='../S/56.html#L396'>p</a>                 396 proc.c               p-&gt;state = RUNNABLE;</span>
<span class='curline'><a href='../S/56.html#L414'>p</a>                 414 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/56.html#L417'>p</a>                 417 proc.c           for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span>
<span class='curline'><a href='../S/56.html#L418'>p</a>                 418 proc.c             if(p-&gt;pid == pid){</span>
<span class='curline'><a href='../S/56.html#L419'>p</a>                 419 proc.c               p-&gt;killed = 1;</span>
<span class='curline'><a href='../S/56.html#L421'>p</a>                 421 proc.c               if(p-&gt;state == SLEEPING)</span>
<span class='curline'><a href='../S/56.html#L422'>p</a>                 422 proc.c                 p-&gt;state = RUNNABLE;</span>
<span class='curline'><a href='../S/56.html#L447'>p</a>                 447 proc.c           struct proc *p;</span>
<span class='curline'><a href='../S/56.html#L451'>p</a>                 451 proc.c           for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span>
<span class='curline'><a href='../S/56.html#L452'>p</a>                 452 proc.c             if(p-&gt;state == UNUSED)</span>
<span class='curline'><a href='../S/56.html#L454'>p</a>                 454 proc.c             if(p-&gt;state &gt;= 0 &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state])</span>
<span class='curline'><a href='../S/56.html#L455'>p</a>                 455 proc.c               state = states[p-&gt;state];</span>
<span class='curline'><a href='../S/56.html#L458'>p</a>                 458 proc.c             cprintf("%d %s %s", p-&gt;pid, state, p-&gt;name);</span>
<span class='curline'><a href='../S/56.html#L459'>p</a>                 459 proc.c             if(p-&gt;state == SLEEPING){</span>
<span class='curline'><a href='../S/56.html#L460'>p</a>                 460 proc.c               getcallerpcs((uint*)p-&gt;context-&gt;ebp+2, pc);</span>
<span class='curline'><a href='../S/64.html#L60'>p</a>                  60 sh.c             int p[2];</span>
<span class='curline'><a href='../S/64.html#L102'>p</a>                 102 sh.c               if(pipe(p) &lt; 0)</span>
<span class='curline'><a href='../S/64.html#L106'>p</a>                 106 sh.c                 dup(p[1]);</span>
<span class='curline'><a href='../S/64.html#L107'>p</a>                 107 sh.c                 close(p[0]);</span>
<span class='curline'><a href='../S/64.html#L108'>p</a>                 108 sh.c                 close(p[1]);</span>
<span class='curline'><a href='../S/64.html#L113'>p</a>                 113 sh.c                 dup(p[0]);</span>
<span class='curline'><a href='../S/64.html#L114'>p</a>                 114 sh.c                 close(p[0]);</span>
<span class='curline'><a href='../S/64.html#L115'>p</a>                 115 sh.c                 close(p[1]);</span>
<span class='curline'><a href='../S/64.html#L118'>p</a>                 118 sh.c               close(p[0]);</span>
<span class='curline'><a href='../S/64.html#L119'>p</a>                 119 sh.c               close(p[1]);</span>
<span class='curline'><a href='../S/73.html#L59'>p</a>                  59 string.c       strncmp(const char *p, const char *q, uint n)</span>
<span class='curline'><a href='../S/73.html#L61'>p</a>                  61 string.c         while(n &gt; 0 &amp;&amp; *p &amp;&amp; *p == *q)</span>
<span class='curline'><a href='../S/73.html#L62'>p</a>                  62 string.c           n--, p++, q++;</span>
<span class='curline'><a href='../S/73.html#L65'>p</a>                  65 string.c         return (uchar)*p - (uchar)*q;</span>
<span class='curline'><a href='../S/78.html#L71'>p</a>                  71 sysfile.c        char *p;</span>
<span class='curline'><a href='../S/78.html#L73'>p</a>                  73 sysfile.c        if(argfd(0, 0, &amp;f) &lt; 0 || argint(2, &amp;n) &lt; 0 || argptr(1, &amp;p, n) &lt; 0)</span>
<span class='curline'><a href='../S/78.html#L75'>p</a>                  75 sysfile.c        return fileread(f, p, n);</span>
<span class='curline'><a href='../S/78.html#L83'>p</a>                  83 sysfile.c        char *p;</span>
<span class='curline'><a href='../S/78.html#L85'>p</a>                  85 sysfile.c        if(argfd(0, 0, &amp;f) &lt; 0 || argint(2, &amp;n) &lt; 0 || argptr(1, &amp;p, n) &lt; 0)</span>
<span class='curline'><a href='../S/78.html#L87'>p</a>                  87 sysfile.c        return filewrite(f, p, n);</span>
<span class='curline'><a href='../S/88.html#L21'>p</a>                  21 uart.c           char *p;</span>
<span class='curline'><a href='../S/88.html#L47'>p</a>                  47 uart.c           for(p="xv6...\n"; *p; p++)</span>
<span class='curline'><a href='../S/88.html#L48'>p</a>                  48 uart.c             uartputc(*p);</span>
<span class='curline'><a href='../S/89.html#L19'>p</a>                  19 ulib.c         strcmp(const char *p, const char *q)</span>
<span class='curline'><a href='../S/89.html#L21'>p</a>                  21 ulib.c           while(*p &amp;&amp; *p == *q)</span>
<span class='curline'><a href='../S/89.html#L22'>p</a>                  22 ulib.c             p++, q++;</span>
<span class='curline'><a href='../S/89.html#L23'>p</a>                  23 ulib.c           return (uchar)*p - (uchar)*q;</span>
<span class='curline'><a href='../S/90.html#L27'>p</a>                  27 umalloc.c        Header *bp, *p;</span>
<span class='curline'><a href='../S/90.html#L30'>p</a>                  30 umalloc.c        for(p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr); p = p-&gt;s.ptr)</span>
<span class='curline'><a href='../S/90.html#L31'>p</a>                  31 umalloc.c          if(p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr))</span>
<span class='curline'><a href='../S/90.html#L33'>p</a>                  33 umalloc.c        if(bp + bp-&gt;s.size == p-&gt;s.ptr){</span>
<span class='curline'><a href='../S/90.html#L34'>p</a>                  34 umalloc.c          bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;</span>
<span class='curline'><a href='../S/90.html#L35'>p</a>                  35 umalloc.c          bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;</span>
<span class='curline'><a href='../S/90.html#L37'>p</a>                  37 umalloc.c          bp-&gt;s.ptr = p-&gt;s.ptr;</span>
<span class='curline'><a href='../S/90.html#L38'>p</a>                  38 umalloc.c        if(p + p-&gt;s.size == bp){</span>
<span class='curline'><a href='../S/90.html#L39'>p</a>                  39 umalloc.c          p-&gt;s.size += bp-&gt;s.size;</span>
<span class='curline'><a href='../S/90.html#L40'>p</a>                  40 umalloc.c          p-&gt;s.ptr = bp-&gt;s.ptr;</span>
<span class='curline'><a href='../S/90.html#L42'>p</a>                  42 umalloc.c          p-&gt;s.ptr = bp;</span>
<span class='curline'><a href='../S/90.html#L43'>p</a>                  43 umalloc.c        freep = p;</span>
<span class='curline'><a href='../S/90.html#L49'>p</a>                  49 umalloc.c        char *p;</span>
<span class='curline'><a href='../S/90.html#L54'>p</a>                  54 umalloc.c        p = sbrk(nu * sizeof(Header));</span>
<span class='curline'><a href='../S/90.html#L55'>p</a>                  55 umalloc.c        if(p == (char*)-1)</span>
<span class='curline'><a href='../S/90.html#L57'>p</a>                  57 umalloc.c        hp = (Header*)p;</span>
<span class='curline'><a href='../S/90.html#L66'>p</a>                  66 umalloc.c        Header *p, *prevp;</span>
<span class='curline'><a href='../S/90.html#L74'>p</a>                  74 umalloc.c        for(p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr){</span>
<span class='curline'><a href='../S/90.html#L75'>p</a>                  75 umalloc.c          if(p-&gt;s.size &gt;= nunits){</span>
<span class='curline'><a href='../S/90.html#L76'>p</a>                  76 umalloc.c            if(p-&gt;s.size == nunits)</span>
<span class='curline'><a href='../S/90.html#L77'>p</a>                  77 umalloc.c              prevp-&gt;s.ptr = p-&gt;s.ptr;</span>
<span class='curline'><a href='../S/90.html#L79'>p</a>                  79 umalloc.c              p-&gt;s.size -= nunits;</span>
<span class='curline'><a href='../S/90.html#L80'>p</a>                  80 umalloc.c              p += p-&gt;s.size;</span>
<span class='curline'><a href='../S/90.html#L81'>p</a>                  81 umalloc.c              p-&gt;s.size = nunits;</span>
<span class='curline'><a href='../S/90.html#L84'>p</a>                  84 umalloc.c            return (void*)(p + 1);</span>
<span class='curline'><a href='../S/90.html#L86'>p</a>                  86 umalloc.c          if(p == freep)</span>
<span class='curline'><a href='../S/90.html#L87'>p</a>                  87 umalloc.c            if((p = morecore(nunits)) == 0)</span>
<span class='curline'><a href='../S/92.html#L1418'>p</a>                1418 usertests.c      char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;</span>
<span class='curline'><a href='../S/92.html#L1455'>p</a>                1455 usertests.c      p = sbrk(amt);</span>
<span class='curline'><a href='../S/92.html#L1456'>p</a>                1456 usertests.c      if (p != a) { </span>
<span class='curline'><a href='../S/92.html#L1550'>p</a>                1550 usertests.c    validateint(int *p)</span>
<span class='curline'><a href='../S/92.html#L1558'>p</a>                1558 usertests.c          "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :</span>
<span class='curline'><a href='../S/92.html#L1566'>p</a>                1566 usertests.c      uint p;</span>
<span class='curline'><a href='../S/92.html#L1571'>p</a>                1571 usertests.c      for(p = 0; p &lt;= (uint)hi; p += 4096){</span>
<span class='curline'><a href='../S/92.html#L1574'>p</a>                1574 usertests.c          validateint((int*)p);</span>
<span class='curline'><a href='../S/92.html#L1583'>p</a>                1583 usertests.c        if(link("nosuchfile", (char*)p) != -1){</span>
<span class='curline'><a href='../S/95.html#L165'>p</a>                 165 vm.c           switchuvm(struct proc *p)</span>
<span class='curline'><a href='../S/95.html#L173'>p</a>                 173 vm.c             if(p-&gt;pgdir == 0)</span>
<span class='curline'><a href='../S/95.html#L175'>p</a>                 175 vm.c             lcr3(v2p(p-&gt;pgdir));  // switch to new address space</span>
<span class='curline'><a href='../S/95.html#L358'>p</a>                 358 vm.c           copyout(pde_t *pgdir, uint va, void *p, uint len)</span>
<span class='curline'><a href='../S/95.html#L363'>p</a>                 363 vm.c             buf = (char*)p;</span>
<span class='curline'><a href='../S/97.html#L63'>p</a>                  63 x86.h          lgdt(struct segdesc *p, int size)</span>
<span class='curline'><a href='../S/97.html#L68'>p</a>                  68 x86.h            pd[1] = (uint)p;</span>
<span class='curline'><a href='../S/97.html#L69'>p</a>                  69 x86.h            pd[2] = (uint)p &gt;&gt; 16;</span>
<span class='curline'><a href='../S/97.html#L77'>p</a>                  77 x86.h          lidt(struct gatedesc *p, int size)</span>
<span class='curline'><a href='../S/97.html#L82'>p</a>                  82 x86.h            pd[1] = (uint)p;</span>
<span class='curline'><a href='../S/97.html#L83'>p</a>                  83 x86.h            pd[2] = (uint)p &gt;&gt; 16;</span>
</pre>
</body>
</html>
