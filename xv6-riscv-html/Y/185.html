<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>lh</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.14' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/32.html#L46'>lh</a>                 46 kernel/log.c     struct logheader lh;</span>
<span class='curline'><a href='../S/32.html#L71'>lh</a>                 71 kernel/log.c     for (tail = 0; tail &lt; log.lh.n; tail++) {</span>
<span class='curline'><a href='../S/32.html#L73'>lh</a>                 73 kernel/log.c         printf("recovering tail %d dst %d\n", tail, log.lh.block[tail]);</span>
<span class='curline'><a href='../S/32.html#L76'>lh</a>                 76 kernel/log.c       struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst</span>
<span class='curline'><a href='../S/32.html#L91'>lh</a>                 91 kernel/log.c     struct logheader *lh = (struct logheader *) (buf-&gt;data);</span>
<span class='curline'><a href='../S/32.html#L93'>lh</a>                 93 kernel/log.c     log.lh.n = lh-&gt;n;</span>
<span class='curline'><a href='../S/32.html#L94'>lh</a>                 94 kernel/log.c     for (i = 0; i &lt; log.lh.n; i++) {</span>
<span class='curline'><a href='../S/32.html#L95'>lh</a>                 95 kernel/log.c       log.lh.block[i] = lh-&gt;block[i];</span>
<span class='curline'><a href='../S/32.html#L109'>lh</a>                109 kernel/log.c     hb-&gt;n = log.lh.n;</span>
<span class='curline'><a href='../S/32.html#L110'>lh</a>                110 kernel/log.c     for (i = 0; i &lt; log.lh.n; i++) {</span>
<span class='curline'><a href='../S/32.html#L111'>lh</a>                111 kernel/log.c       hb-&gt;block[i] = log.lh.block[i];</span>
<span class='curline'><a href='../S/32.html#L122'>lh</a>                122 kernel/log.c     log.lh.n = 0;</span>
<span class='curline'><a href='../S/32.html#L134'>lh</a>                134 kernel/log.c       } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS &gt; LOGBLOCKS){</span>
<span class='curline'><a href='../S/32.html#L184'>lh</a>                184 kernel/log.c     for (tail = 0; tail &lt; log.lh.n; tail++) {</span>
<span class='curline'><a href='../S/32.html#L186'>lh</a>                186 kernel/log.c       struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block</span>
<span class='curline'><a href='../S/32.html#L197'>lh</a>                197 kernel/log.c     if (log.lh.n &gt; 0) {</span>
<span class='curline'><a href='../S/32.html#L201'>lh</a>                201 kernel/log.c       log.lh.n = 0;</span>
<span class='curline'><a href='../S/32.html#L221'>lh</a>                221 kernel/log.c     if (log.lh.n &gt;= LOGBLOCKS)</span>
<span class='curline'><a href='../S/32.html#L226'>lh</a>                226 kernel/log.c     for (i = 0; i &lt; log.lh.n; i++) {</span>
<span class='curline'><a href='../S/32.html#L227'>lh</a>                227 kernel/log.c       if (log.lh.block[i] == b-&gt;blockno)   // log absorption</span>
<span class='curline'><a href='../S/32.html#L230'>lh</a>                230 kernel/log.c     log.lh.block[i] = b-&gt;blockno;</span>
<span class='curline'><a href='../S/32.html#L231'>lh</a>                231 kernel/log.c     if (i == log.lh.n) {  // Add new block to log?</span>
<span class='curline'><a href='../S/32.html#L233'>lh</a>                233 kernel/log.c       log.lh.n++;</span>
</pre>
</body>
</html>
